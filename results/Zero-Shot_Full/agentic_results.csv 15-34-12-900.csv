question_id,question,ground_truth_query,generated_query,success,total_iterations,first_attempt_valid,bleu,rouge_l_f1,jaro_winkler,jaccard_cypher,pass_at_1,jaccard_output,llmetric_q,reasoning_level,sublevel,complexity,errors_encountered
1,Berapakah jumlah SKS untuk mata kuliah 'Aljabar Linear'?,MATCH (n:MK {nama: 'Aljabar Linear'}) RETURN n.sks,MATCH (m:MK) WHERE m.nama = 'Aljabar Linear' RETURN m.sks,True,1,True,9.460044053305668e-155,0.7,0.8899454343522141,0.6363636363636364,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
2,Apakah nama lengkap dari mata kuliah dengan kode 'TKU211131'?,MATCH (n:MK {kode: 'TKU211131'}) RETURN n.nama,MATCH (m:MK {kode: 'TKU211131'}) RETURN m.nama,True,1,True,0.6389431042462724,0.75,0.9816809605488851,0.75,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
3,Bagaimanakah deskripsi untuk Capaian Lulusan (SO) dengan kode 'KP.1'?,MATCH (n:SO {kode: 'KP.1'}) RETURN n.deskripsi,MATCH (s:SO {kode: 'KP.1'}) RETURN s.deskripsi,True,1,True,0.6901670171940026,0.7778,0.9677830940988835,0.7777777777777778,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
4,Tampilkan seluruh mata kuliah yang ditawarkan pada semester 1.,MATCH (n:MK) WHERE n.semester = 1 RETURN n.nama,MATCH (m:MK) WHERE m.semester = 1 RETURN m,True,1,True,0.4197010774824036,0.6316,0.8806785243741766,0.7,False,0.14285714285714285,50.41853547901374,Fakta Eksplisit,Nodes,Easy,
5,Tampilkan nama dan kode untuk semua mata kuliah yang memiliki tipe 'Pilihan'.,"MATCH (n:MK) WHERE n.tipe = 'Pilihan' RETURN n.nama, n.kode","MATCH (m:MK) WHERE m.tipe = 'Pilihan' RETURN m.nama, m.kode",True,1,True,0.4062749424452353,0.6667,0.9256277056277057,0.8181818181818182,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
6,Apa sajakah klasifikasi unik yang ada untuk semua mata kuliah?,MATCH (n:MK) RETURN DISTINCT n.klasifikasi,MATCH (m:MK) RETURN DISTINCT m.klasifikasi,True,1,True,0.4497332084013506,0.7143,0.9833333333333334,0.7142857142857143,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
7,Berapakah jumlah total mata kuliah yang bertipe 'Wajib'?,MATCH (n:MK) WHERE n.tipe = 'Wajib' RETURN COUNT(n),MATCH (m:MK) WHERE m.tipe = 'Wajib' RETURN COUNT(m) AS total,True,1,True,0.4790714250659131,0.6364,0.9552173913043478,0.6666666666666666,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
8,"Tampilkan semua mata kuliah, diurutkan berdasarkan semester dari awal hingga akhir.","MATCH (n:MK) RETURN n.nama, n.semester ORDER BY n.semester",MATCH (m:MK) RETURN m ORDER BY m.semester ASC,True,1,True,0.1860067949655926,0.5455,0.843949864867316,0.6,False,0.2777777777777778,52.50280487989214,Fakta Eksplisit,Nodes,Medium,
9,Sebutkan 5 mata kuliah yang diurutkan berdasarkan namanya.,MATCH (n:MK) RETURN n.nama ORDER BY n.nama LIMIT 5,MATCH (m:MK) RETURN m ORDER BY m.nama LIMIT 5,True,1,True,0.34245097009375325,0.6957,0.883571359578314,0.8,False,0.1388888888888889,50.67413457566935,Fakta Eksplisit,Nodes,Medium,
10,Berapakah rata-rata jumlah SKS pada tiap semester.,"MATCH (n:MK) RETURN n.semester, AVG(n.sks) ORDER BY n.semester","MATCH (m:MK) WITH m.semester AS semester, AVG(m.sks) AS average_sks ORDER BY semester RETURN semester, average_sks",True,3,False,0.19287166967040906,0.4706,0.6886181401323263,0.6153846153846154,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,syntax_error
11,Berapakah SKS minimum dan maksimum untuk mata kuliah dengan klasifikasi 'Sains Dasar'?,"MATCH (n:MK) WHERE n.klasifikasi = 'Sains Dasar' RETURN MIN(n.sks), MAX(n.sks)","MATCH (m:MK) WHERE m.klasifikasi = 'Sains Dasar' RETURN MIN(m.sks) AS min_sks, MAX(m.sks) AS max_sks",True,1,True,0.4299524507438839,0.6111,0.8661665590956209,0.6875,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
12,Apa saja 'jalur' peminatan mata kuliah yang terdapat pada kurikulum?,MATCH (n:MK) WHERE n.jalur IS NOT NULL RETURN DISTINCT n.jalur,MATCH (m:MK) RETURN DISTINCT m.jalur,True,1,True,2.984428797065476e-78,0.5,0.8447619047619048,0.45454545454545453,False,0.8,62.72380952380952,Fakta Eksplisit,Nodes,Medium,
13,Tolong daftarkan mata kuliah di tiap semester dan diurutkan per semester.,"MATCH (n:MK) WITH n.semester AS semester, COLLECT(n.nama) AS daftarMataKuliah RETURN semester, daftarMataKuliah ORDER BY semester","MATCH (m:MK) RETURN m.semester AS semester, collect(m.nama) AS courses ORDER BY semester ASC",True,1,True,0.3143024423474699,0.6111,0.8408231714344989,0.6,True,1.0,100.0,Fakta Eksplisit,Nodes,Hard,
14,Kelompokkan semua nama mata kuliah berdasarkan tipenya.,"MATCH (n:MK) WITH n.tipe AS tipeMK, COLLECT(n.nama) AS daftarMatkul RETURN tipeMK, daftarMatkul","MATCH (m:MK) RETURN m.tipe AS tipe, collect(m.nama) AS mata_kuliah",True,1,True,0.19873241117714635,0.4667,0.8355790179319591,0.5384615384615384,True,1.0,100.0,Fakta Eksplisit,Nodes,Hard,
15,"Untuk mata kuliah 'Aljabar Linear' dan 'Statistika', kumpulkan semua deskripsi topik dari kedua mata kuliah tersebut.","UNWIND ['Aljabar Linear', 'Statistika'] AS namaMK MATCH (t:topic {MK: namaMK}) RETURN namaMK, COLLECT(t.deskripsi) AS daftarTopik","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama IN ['Aljabar Linear','Statistika'] RETURN COLLECT(t.deskripsi) AS deskripsiTopik",True,3,False,0.3872323459769236,0.4737,0.734082436488762,0.55,False,0.0,46.03891218244381,Fakta Eksplisit,Nodes,Hard,syntax_error
16,"Hitung jumlah total mata kuliah, dan berikan juga jumlah mata kuliah yang memiliki klasifikasi 'Sains Dasar'.","MATCH (n:MK) WITH n, CASE WHEN n.klasifikasi = 'Sains Dasar' THEN 1 ELSE 0 END AS isSainsDasar RETURN count(n) AS total, sum(isSainsDasar) AS totalSainsDasar","MATCH (m:MK) RETURN COUNT(m) AS totalMK, COUNT(CASE WHEN m.klasifikasi = 'Sains Dasar' THEN 1 ELSE NULL END) AS sainsDasarCount",True,1,True,0.2780466795300193,0.4898,0.8284511826013119,0.5769230769230769,True,1.0,100.0,Fakta Eksplisit,Nodes,Hard,
17,Sebutkan topik dan deskripsinya yang dibahas dalam mata kuliah 'Aljabar Linear',"MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN t.nama, t.deskripsi","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama = 'Aljabar Linear' RETURN t.nama, t.deskripsi",True,1,True,0.7199284907229773,0.9375,0.9390216473776574,0.8461538461538461,True,1.0,100.0,Fakta Implisit,One-hop,Easy,
18,Apakah Capaian Pembelajaran (LO) yang diharapkan dari mata kuliah 'Pemrograman Dasar'?,MATCH (l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Pemrograman Dasar'}) RETURN l.deskripsi,"MATCH (lo:LO)-[:PURSUED_IN]->(mk:MK) WHERE mk.nama = 'Pemrograman Dasar' RETURN lo.nama AS nama_capaian, lo.deskripsi AS deskripsi_capaian",True,1,True,0.32247556920239,0.5556,0.8288043038997778,0.5,False,0.5,56.92202151949889,Fakta Implisit,One-hop,Easy,
19,Apakah Tujuan Pembelajaran (LG) dari mata kuliah 'Aljabar Linear'?,MATCH (l:LG)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN l.deskripsi,MATCH (lg:LG)-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN lg,True,1,True,0.6879186357518018,0.72,0.9687686310479248,0.6153846153846154,False,0.3333333333333333,55.11050982190629,Fakta Implisit,One-hop,Easy,
20,Mata kuliah apa yang mencakup topik dengan deskripsi 'Determinan'?,MATCH (t:topic {deskripsi: 'Determinan'})-[:PURSUED_IN]->(m:MK) RETURN m.nama,MATCH (t:topic {deskripsi: 'Determinan'})-[:PURSUED_IN]->(mk:MK) RETURN mk,True,1,True,0.7724579032182339,0.7826,0.9812191842223219,0.7272727272727273,False,0.16666666666666666,52.15242925444495,Fakta Implisit,One-hop,Easy,
21,Mata kuliah apa yang menjadi prasyarat untuk mengambil 'Kecerdasan Buatan'?,MATCH (p:MK)-[:PREREQUISITE]->(t:MK {nama: 'Kecerdasan Buatan'}) RETURN p.nama,"MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: 'Kecerdasan Buatan'}) RETURN prereq.kode, prereq.nama, prereq.sks, prereq.durasi, prereq.tipe, prereq.klasifikasi, prereq.semester, prereq.jalur",True,1,True,0.33854265693255753,0.4737,0.8286586429443572,0.3888888888888889,False,0.13333333333333333,49.17845988138845,Fakta Implisit,One-hop,Easy,
22,Mata kuliah apa yang dapat diparalelkan dengan 'Fisika Mekanika Klasik'?,MATCH (m1:MK {nama: 'Fisika Mekanika Klasik'})-[:CAN_PARALLELIZED]->(m2:MK) RETURN m2.nama,MATCH (m:MK {nama: 'Fisika Mekanika Klasik'})-[:CAN_PARALLELIZED]->(p:MK) RETURN p.nama,True,3,False,0.7224637864373493,0.7857,0.9681231541044625,0.6666666666666666,True,1.0,100.0,Fakta Implisit,One-hop,Easy,syntax_error
23,Berapakah jumlah topik yang ada pada mata kuliah 'Aljabar Linear'?,MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN count(t),MATCH (t:topic)-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN count(t),True,1,True,0.9025139799587886,0.9231,0.998,0.8333333333333334,True,1.0,100.0,Fakta Implisit,One-hop,Medium,
24,Sebutkan kode Capaian Lulusan (SO) unik yang dikejar (pursued) pada mata kuliah semester 1.,MATCH (s:SO)-[:PURSUED_IN]->(m:MK) WHERE m.semester = 1 RETURN DISTINCT s.kode,MATCH (so:SO)-[:PURSUED_IN]->(mk:MK) WHERE mk.semester = 1 RETURN DISTINCT so.kode,True,1,True,0.6148406922119201,0.7333,0.9549658058589364,0.7333333333333333,True,1.0,100.0,Fakta Implisit,One-hop,Medium,
25,"Tampilkan mata kuliah beserta jumlah topiknya, diurutkan secara menurun berdasarkan jumlah topik.","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) RETURN m.nama, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC","MATCH (m:MK)-[:PURSUED_IN]-(t:topic) WITH m, COUNT(t) AS jumlah_topik ORDER BY jumlah_topik DESC RETURN m.nama AS nama_mata_kuliah, m.kode AS kode_mata_kuliah, jumlah_topik",True,2,False,0.38832772456409065,0.3846,0.833640193850443,0.6842105263157895,False,0.17110266159695817,49.51325420119137,Fakta Implisit,One-hop,Medium,syntax_error
26,Identifikasi 3 mata kuliah teratas yang memiliki jumlah topik terbanyak.,"MATCH (t:topic)-[:PURSUED_IN]->(m:MK) RETURN m.nama, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC LIMIT 3","<think> Okay, let's see. The user wants to find the top 3 courses with the most topics. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there's a typo or a missing keyword. Looking at the previous query, maybe the issue is with the WITH clause. Oh right, in Cypher, when using WITH, you need to specify the order and limit before returning. Wait, the user's query had ""WITH m, COUNT(t) AS topicCount ORDER BY topicCount DESC LIMIT 3"". But in Cypher, the ORDER BY and LIMIT come after the WITH clause. Wait, no, actually, in Cypher, the correct syntax is to have the ORDER BY and LIMIT in the same clause as the WITH. Wait, no, the WITH clause is used to pass variables to the next part of the query. So after the WITH, you can do ORDER BY and LIMIT in the RETURN clause. Wait, maybe the user missed a comma or a keyword. Wait, the error message says ""Invalid input '<': expected ..."". The character at position 8 is probably a less-than symbol, which isn't valid here. Let me check the original query again. Oh, maybe the user used a less-than symbol instead of a colon in a label or relationship type. Wait, no, looking at the previous query, maybe they used a wrong character in the relationship direction. For example, using a less-than symbol instead of a hyphen. Wait, in Cypher, relationships are written with hyphens and arrows. Like (t:topic)-[:PURSUED_IN]->(m:MK). If there's a typo here, like using a less-than symbol instead of a hyphen, that would cause an error. Let me check the original query again. The user's query was: MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WITH m, COUNT(t) AS topicCount ORDER BY topicCount DESC LIMIT 3 RETURN m Wait, the error is at line 1, column 9. Let's count the characters. The first part is ""MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WITH m, COUNT(t) AS topicCount ORDER BY topicCount DESC LIMIT 3 RETURN m"". The 9th character after MATCH is the hyphen in ""-[:PURSUED_IN]->"". Wait, maybe the user used",False,3,False,0.042791918740189616,0.0856,0.4988312759586921,0.0958904109589041,False,0.0,2.9221563797934604,Fakta Implisit,One-hop,Medium,"syntax_error,properties_error"
27,Berapa mata kuliah prasyarat untuk mengambil mata kuliah Proyek Senior Teknologi Informasi?,MATCH (p:MK)-[:PREREQUISITE]->(t:MK {nama: 'Proyek Senior Teknologi Informasi'}) RETURN COUNT(p),"MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: ""Proyek Senior Teknologi Informasi""}) RETURN COUNT(prereq) AS jumlah_prasyarat",True,1,True,0.5395675853277331,0.7097,0.8840135682240946,0.4444444444444444,True,1.0,100.0,Fakta Implisit,One-hop,Medium,
28,Mata kuliah manakah yang paling banyak menjadi prasyarat bagi mata kuliah lainnya?,"MATCH (p:MK)-[:PREREQUISITE]->(t:MK) RETURN p.nama, count(t) AS jumlahMatkul ORDER BY jumlahMatkul DESC LIMIT 1","<think> Okay, let's see. The user wants to find the course (MK) that has the most prerequisites, meaning other courses depend on it. The previous query tried to count the number of PREREQUISITE relationships from each MK node to others. But there was an error. The error mentioned an unknown property. Wait, the original query was: MATCH (m:MK)-[:PREREQUISITE]->(other:MK) WITH m, COUNT(other) AS prereqCount ORDER BY prereqCount DESC RETURN m LIMIT 1 Hmm, maybe the problem is in the COUNT. Oh right, in Cypher, when you use COUNT, you need to make sure you're grouping correctly. The WITH clause should group by m, otherwise COUNT might not work as intended. Wait, but the error was about unknown properties. Let me check the properties again. The MK node has properties like kode, nama, sks, etc. The query doesn't use any properties, just the nodes. So maybe the error is in the syntax of the COUNT. Oh, right! When using COUNT with a WITH clause, you need to include the variable you're grouping by. The original query uses WITH m, COUNT(other) AS prereqCount, which groups by m, so that's correct. But maybe the error is because the ORDER BY is on a variable that's not in the WITH clause? Wait, no, the WITH includes m and prereqCount. Wait, no, the ORDER BY is after the WITH. Let me think again. Wait, the error message says ""Unknown error"" but the detail says ""KESALAHAN PROPERTI TERDETEKSI"" which translates to ""Property error detected"". The user's query doesn't reference any properties, so maybe the error is in the relationship direction. Wait, the PREREQUISITE relationship is from a course to its prerequisite. Wait, no, if a course is a prerequisite for another, the direction might be the other way. For example, if course A is a prerequisite for course B, the relationship would be from B to A as PREREQUISITE. So when we match (m)-[:PREREQUISITE]->(other), m is the course that requires other as a prerequisite. So to find which course is most often a prerequisite, we need to count how many times a course is the target of PREREQUISITE relationships. Wait, no. Let me clarify: If course B has a prerequisite",False,3,False,0.028207877616038757,0.0553,0.5336308393704332,0.07741935483870968,False,0.0,2.9446541968521665,Fakta Implisit,One-hop,Medium,"syntax_error,properties_error"
29,Sebutkan semua topik dari 'Metode Numeris' yang termasuk dalam 'LO1' atau 'LO2'.,"MATCH (t:topic)-[:PART_OF]->(l:LO {MK: 'Metode Numeris'}) WHERE l.nama IN ['LO1', 'LO2'] RETURN l.nama, t.deskripsi","<think> Okay, let's tackle this problem step by step. The user wants all topics from 'Metode Numeris' that are part of 'LO1' or 'LO2'. First, I need to recall the schema. The relevant relationships here are: - Topics are pursued in MK via PURSUED_IN. - Topics are part of LO via PART_OF. - LOs are part of SO, which are part of LG, but the user only needs up to LO. So the correct path should be: topic -> PART_OF -> LO -> PURSUED_IN -> MK. Wait, no, the PURSUED_IN for LO is to MK. Let me check the schema again. Looking at the schema: (:LO {nama: STRING, deskripsi: STRING, MK: STRING})-[:PURSUED_IN]->(:MK {kode: STRING, nama: STRING, ...}) So LOs are pursued in MK. Topics are part of LOs. So the path is topic -> PART_OF -> LO -> PURSUED_IN -> MK. So the query should start by matching topics that are part of LOs which are pursued in the MK 'Metode Numeris', and the LOs are either 'LO1' or 'LO2'. The previous query had a syntax error. The user tried to use OR inside the property map, which isn't allowed. Instead, the WHERE clause should handle the OR condition. So the correct approach is: 1. Match the topic nodes that are part of LOs. 2. Ensure those LOs are pursued in the MK 'Metode Numeris'. 3. Filter LOs to be either 'LO1' or 'LO2'. Putting this into Cypher: MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PURSUED_IN]->(mk:MK {nama: 'Metode Numeris'}) WHERE lo.nama IN ['LO1', 'LO2'] RETURN t Wait, but the LO's PURSUED_IN relationship is to MK. So the path is topic -> PART_OF -> LO, which is PURSUED_IN -> MK. So the correct pattern is (t:topic)-[:PART_OF]->(lo:LO)-[:PURSUED_IN]->(mk:MK). Then, check that mk.nama is 'Metode Numeris' and lo.nama is either 'LO1' or 'LO2'. Yes, that makes sense. So the query should be: MATCH (t:topic)-",False,3,False,0.05886729412891485,0.0977,0.5271634955377167,0.13043478260869565,False,0.0,3.1243174776885834,Fakta Implisit,One-hop,Medium,syntax_error
30,Tolong kumpulkan semua deskripsi topik yang diajarkan di mata kuliah 'Aljabar Linear'.,"MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) WITH m, COLLECT(t.deskripsi) AS daftarTopik RETURN m.nama, daftarTopik",MATCH (t:topic)-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN t.deskripsi,True,1,True,0.4952683346469174,0.6471,0.8725980392156862,0.625,False,0.0,47.59849019607843,Fakta Implisit,One-hop,Hard,
31,Tolong verifikasi: Apakah topik 'Determinan' merupakan bagian dari 'LO1' pada 'Aljabar Linear'?,"MATCH (t:topic {deskripsi: 'Determinan'})-[:PART_OF]->(l:LO {nama: 'LO1', MK: 'Aljabar Linear'}) RETURN CASE WHEN l IS NOT NULL THEN 'Ya' ELSE 'Tidak' END AS Jawaban","<think> Okay, let's see. The user wants to check if the topic 'Determinan' is part of 'LO1' in 'Aljabar Linear'. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there's a typo or a missing keyword. Looking at the original query: MATCH (t:topic {nama: 'Determinan'})-[:PART_OF]->(lo:LO {nama: 'LO1'})-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN t. Wait, the error is at column 9. Let me count. The first part is MATCH (t:topic {nama: 'Determinan'})-[:PART_OF]->(lo:LO... The hyphen after the relationship might be the issue. Oh, right! In Cypher, when you have a relationship pattern, you need to use the correct syntax. The hyphen should be followed by a colon for the relationship type. Wait, no, the syntax is correct here. The problem might be that the user used a hyphen without a colon? No, the original query uses -[:PART_OF]-> which is correct. Wait, maybe the issue is that the user is using a string in the property without quotes? No, the properties are correctly enclosed in curly braces with quotes. Wait, in the error message, it says ""Invalid input '<'"". Hmm, maybe there's a hidden character or a typo in the query. Let me check again. Oh, wait! The user might have accidentally included a less-than symbol '<' instead of a hyphen '-'. But in the query provided, the user used hyphens. Maybe the problem is that the user is using a different keyboard layout and accidentally typed a different character. Alternatively, maybe the query was pasted with some invisible characters. Alternatively, maybe the issue is that the user is missing a keyword. Let me check the correct syntax. The correct pattern is (node)-[:REL]->(node). So the original query's pattern is correct. Wait, maybe the problem is that the user is using a version of Neo4j that doesn't support certain syntax. But the error is a syntax error, so it's more likely a typo. Wait, looking at the error message again: ""Invalid input '<'"". The character at position 8 (offset 8) is the first hyphen in the relationship.",False,3,False,0.04743480967129707,0.0765,0.5350286891832851,0.08588957055214724,False,0.0,3.0576434459164257,Fakta Implisit,One-hop,Hard,"syntax_error,empty_result"
32,"Untuk mata kuliah 'Kalkulus Variabel Tunggal' dan 'Matematika Diskrit', apa saja topik materi yang diajarkan?","UNWIND ['Kalkulus Variabel Tunggal', 'Matematika Diskrit'] AS namaMK MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: namaMK}) RETURN namaMK, t.deskripsi","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama IN ['Kalkulus Variabel Tunggal','Matematika Diskrit'] RETURN t.nama,t.deskripsi",True,2,False,0.6369446989057785,0.5238,0.7975016212694648,0.7368421052631579,False,0.3333333333333333,53.27317477301399,Fakta Implisit,One-hop,Hard,syntax_error
33,"Untuk setiap Tujuan Pembelajaran (LG) yang ada, sebutkan semua Capaian Lulusan (SO) yang menjadi bagiannya.","MATCH (s:SO)-[:PART_OF]->(l:LG) WITH l.nama AS namaLG, COLLECT(s.kode) AS daftarSO RETURN namaLG, daftarSO","<think> Okay, let's tackle this problem. The user wants to list all Learning Outcomes (SO) that are part of each Learning Goal (LG). From the schema, there's a relationship called PART_OF from SO to LG. So each SO is part of an LG. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. That probably means there was a typo or incorrect use of the relationship direction. Let me check the correct syntax for relationships in Cypher. The correct pattern should be MATCH (lg:LG)<-[:PART_OF]-(so:SO) RETURN lg, so. Wait, but maybe the user used a different direction. Let me confirm the schema again. The schema says (:SO)-[:PART_OF]->(:LG), so the relationship is from SO to LG. To get all SOs under each LG, we need to traverse from LG to SO via the inverse direction. So the correct pattern is (lg:LG)<-[:PART_OF]-(so:SO). But in the previous query, maybe there was a typo in the relationship name or the direction. Let me make sure that the relationship is correctly named PART_OF and that the direction is correct. Also, check for any missing quotes or brackets. Oh, right, in Cypher, the relationship type is enclosed in square brackets. So the correct syntax is [:PART_OF]. Wait, the error message mentioned an invalid input '<' which might be due to a missing colon or incorrect syntax. Let me reconstruct the query step by step. Start with MATCH, then the pattern. The pattern should be (lg:LG) connected to (so:SO) via the PART_OF relationship in the correct direction. Since the relationship is from SO to LG, the correct pattern is (so:SO)-[:PART_OF]->(lg:LG). But to get all SOs under each LG, we need to collect them. However, the user wants to list each SO per LG. So the query should match all SOs that are part of any LG and return both. Wait, but the user's question is to list for each LG, all its SOs. So the correct approach is to match each LG and then find all SOs connected via PART_OF. So the query would be MATCH (lg:LG)<-[:PART_OF]-(so:SO) RETURN lg, so. Wait, but maybe the user had a typo in the relationship direction.",False,3,False,0.022332956065864842,0.0434,0.5256001064797515,0.050724637681159424,False,0.0,2.8450005323987577,Fakta Implisit,One-hop,Hard,syntax_error
34,"Tampilkan semua mata kuliah, beserta daftar mata kuliah prasyaratnya (jika ada).","MATCH (m:MK) OPTIONAL MATCH (p:MK)-[:PREREQUISITE]->(m) WITH m.nama AS nama, COLLECT(p.nama) AS prasyarat RETURN nama, prasyarat","<think> Okay, let's see. The user wants to display all courses along with their prerequisite courses. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there's a typo or a missing keyword. Looking at the schema, the PREREQUISITE relationship is from MK to another MK. So the correct approach is to match all MK nodes and then find their prerequisites. The previous attempt might have used a wrong syntax for the relationship direction or type. In Cypher, relationships are defined with [-:REL_TYPE->], but maybe the user used a different syntax. Let me check the correct syntax. Oh right, it's (m)-[:PREREQUISITE]->(p). Also, the user might have missed the colon before the relationship type. Oh wait, in the previous query, maybe they used something like (m)-[PREREQUISITE]->(p) without the colon, which is incorrect. The correct is (m)-[:PREREQUISITE]->(p). So the corrected query should use the correct relationship syntax. Also, using OPTIONAL MATCH to include courses without prerequisites. Then collect the prerequisites into a list. Let me structure the query properly. MATCH (m:MK) OPTIONAL MATCH (m)-[:PREREQUISITE]->(p:MK) RETURN m.nama AS nama, collect(p.nama) AS prasyarat. Wait, but the user wants to return the MK nodes, not just the names. But the error might be in the syntax of the relationship. Let me make sure all keywords are correctly spelled and the relationship is properly defined with colons. Another thing: the user might have used a different case for the relationship type. The schema says PREREQUISITE, so it's case-sensitive. Also, ensuring that the RETURN clause is correctly using the properties. So the corrected query should be: MATCH (m:MK) OPTIONAL MATCH (m)-[:PREREQUISITE]->(p:MK) RETURN m, collect(p) AS prasyarat. But the error was about invalid input '<', which might be due to a missing colon in the relationship type. For example, if the previous query had (m)-[PREREQUISITE]->(p), that's wrong. It should be (m)-[:PREREQUISITE]->(p). Putting it all together, the correct query should have the",False,3,False,0.05796322377336056,0.0963,0.544258824875565,0.0851063829787234,False,0.0,3.2027941243778244,Fakta Implisit,One-hop,Hard,syntax_error
35,Agregasikan semua deskripsi Capaian Pembelajaran (LO) yang berkontribusi pada kompetensi lulusan 'KP.1'.,"MATCH (l:LO)-[:PART_OF]->(s:SO {kode: 'KP.1'}) WITH s, COLLECT(l.deskripsi) AS daftarCapaian RETURN s.kode, daftarCapaian","<think> Okay, let's see. The user wants to aggregate all the Learning Outcomes (LO) descriptions that contribute to the graduate competency 'KP.1'. First, I need to recall the schema. The LO nodes are connected to MK via PURSUED_IN. But the main path here is about the LG (Graduate Competency) with kode 'KP.1'. The relationships are: LG is part of SO, and SO is part of LO. Wait, no, the schema says that LO is part of SO, and SO is part of LG. So the correct path is LG <- SO <- LO. So the query should start by matching the LG node with kode 'KP.1', then go through the PART_OF relationships in reverse to get to SO and then LO. Then collect the deskripsi from those LOs. The previous query had a syntax error. The user mentioned an invalid input '<' which probably means the direction of the relationships was written incorrectly. In Cypher, relationships can be traversed in either direction, but the direction in the query must match the schema's defined direction. Looking at the schema: - (:LO)-[:PART_OF]->(:SO) - (:SO)-[:PART_OF]->(:LG) So to get from LG to LO, we need to traverse the relationships in the reverse direction. So the correct pattern would be (lg:LG {kode: 'KP.1'})<-[:PART_OF]-(so:SO)<-[:PART_OF]-(lo:LO). But in Cypher, when you use the <-[:REL_TYPE]- syntax, it's correct. However, maybe the previous query had a typo or incorrect syntax. The error message mentioned an invalid input '<', which might be due to a missing colon in the label or a typo in the relationship type. So the corrected query should be: MATCH (lg:LG {kode: 'KP.1'})<-[:PART_OF]-(so:SO)<-[:PART_OF]-(lo:LO) RETURN collect(lo.deskripsi) AS descriptions Wait, but the user wants to aggregate all the descriptions. Using collect() is correct here. Also, ensure that the properties are correctly named. The LG node has a 'kode' property, and the error message might have been due to a missing colon in the label or a typo in the relationship direction. Another thing to check is the use of quotes. All string values should be in double quotes. The previous query might have had unquoted string literals or incorrect",False,3,False,0.03802491435004858,0.0647,0.5285399930974568,0.07894736842105263,False,0.0,2.9661999654872844,Fakta Implisit,One-hop,Hard,syntax_error
36,Hitung jumlah Capaian Pembelajaran (LO) di 'Metode Numeris' yang merupakan bagian dari SO 'KP.2'.,"MATCH (l:LO {MK: 'Metode Numeris'})-[:PART_OF]->(s:SO {kode: 'KP.2'}) WITH s, count(l) AS jumlahLO RETURN s.kode, jumlahLO","MATCH (lo:LO)-[:PURSUED_IN]->(mk:MK {nama: ""Metode Numeris""})-[:PART_OF]->(so:SO {kode: ""KP.2""}) RETURN count(lo) AS jumlah",False,3,False,0.30314950705552174,0.5778,0.8520141700404859,0.3333333333333333,False,0.0,7.149070850202429,Fakta Implisit,One-hop,Hard,"syntax_error,schema_error"
37,Topik apa saja yang menjadi bagian dari Capaian Pembelajaran (LO) di 'Aljabar Linear'? berikan juga deskripsi topiknya,MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN t.nama,"MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN t.nama AS nama_topik, t.deskripsi AS deskripsi_topik",True,1,True,0.7040483669919072,0.7143,0.9423728813559322,0.5789473684210527,False,0.5,58.28336440677966,Fakta Implisit,Multi-hop,Easy,
38,"Apa saja topik yang terkait dengan Capaian Lulusan (SO) 'KP.1' melalui LO. Berikan nama mata kuliah, nama topik dan deskripsi topiknya","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK) WHERE (l)-[:PART_OF]->(:SO {kode: 'KP.1'}) RETURN m.nama AS mataKuliah, t.nama AS namaTopic, t.deskripsi AS deskripsiTopik","<think> Okay, let's see. The user wants to find topics related to the SO 'KP.1' through LO. They need the course name, topic name, and description. First, I need to recall the schema. The SO node is connected to LO via PART_OF. Then, LO is part of SO. Topics are part of LO through PART_OF. Also, topics are pursued in MK via PURSUED_IN. So the path should be SO -> PART_OF -> LO -> PART_OF -> topic, then topic -> PURSUED_IN -> MK. Wait, the relationships are: (:topic)-[:PART_OF]->(:LO), (:LO)-[:PART_OF]->(:SO), and (:SO)-[:PART_OF]->(:LG). But the user is starting from SO 'KP.1', so the correct path is SO to LO (since LO is part of SO?), but the direction might be important. Wait, the schema says (:LO)-[:PART_OF]->(:SO), so LO is part of SO. So to get LOs related to SO, we need to match (so)-[:PART_OF]-(lo)? No, wait, the direction is from LO to SO. So the correct pattern is (lo)-[:PART_OF]->(so). So to find LOs that are part of SO 'KP.1', we should match (so:SO {kode: 'KP.1'})<-[:PART_OF]-(lo). Then, topics are part of LO, so (topic)-[:PART_OF]->(lo). Then, topics are pursued in MK via PURSUED_IN. So (topic)-[:PURSUED_IN]->(mk:MK). Putting it all together: MATCH (so:SO {kode: 'KP.1'})<-[:PART_OF]-(lo)-[:PART_OF]-(topic)-[:PURSUED_IN]->(mk:MK) RETURN mk.nama AS mata_kuliah, topic.nama AS nama_topik, topic.deskripsi AS deskripsi_topik. Wait, but in the schema, the PURSUED_IN relationship is from topic to MK. So the pattern is correct. Also, need to make sure that the properties are correctly accessed. The SO's code is 'kode', so the WHERE clause should be (so:SO {kode: 'KP.1'}). Now, checking the syntax. The previous query had an error at line 1, column 9. The error message mentions invalid input '<', which might be",False,3,False,0.07793860382946827,0.1096,0.5509116909354136,0.12396694214876033,False,0.0,3.3025584546770683,Fakta Implisit,Multi-hop,Easy,syntax_error
39,Capaian Lulusan (SO) apa saja yang terkait dengan Tujuan Pembelajaran (LG) 'Aljabar Linear'?,MATCH (s:SO)-[:PART_OF]->(l:LG)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN s.kode,"<think> Okay, let's see. The user is asking for the Capaian Lulusan (SO) related to the Learning Goal (LG) ""Aljabar Linear"". The previous query was MATCH (so:SO)-[:PART_OF]->(lg:LG {nama: ""Aljabar Linear""}) RETURN so, but it returned empty results. Hmm, maybe the direction of the relationship is wrong. The PART_OF relationship usually goes from a more specific node to a more general one. For example, SO might be part of LG, or maybe the other way around. Wait, according to the schema, the relationships are: (:SO)-[:PART_OF]->(:LG). Wait, no, the schema says: (:topic)-[:PART_OF]->(:LO) (:LO)-[:PART_OF]->(:SO) (:SO)-[:PART_OF]->(:LG) So the hierarchy is topic part of LO, LO part of SO, SO part of LG. So if the user wants SO related to LG ""Aljabar Linear"", maybe the SO is part of that LG. So the correct relationship would be (so:SO)-[:PART_OF]->(lg:LG). But in the previous query, they had SO connected via PART_OF to LG, which according to the schema is correct. But maybe the LG's nama is not exactly ""Aljabar Linear"". Maybe there's a typo or case sensitivity issue. For example, maybe the actual nama is ""aljabar linear"" with lowercase letters. The user's query uses ""Aljabar Linear"" with uppercase, but the data might have it in lowercase. Since Neo4j is case-sensitive, that would cause a mismatch. Another possibility is that the LG node isn't connected directly to SO. Wait, according to the schema, the SO is part of LG via PART_OF. So the SO nodes are connected to LG via PART_OF. So the original query's pattern is correct. But if there's no SO nodes connected to that LG, maybe because the LG's name is different. Let me check the schema again. The LG has a MK property, which is a string. Wait, the LG node has properties: nama, deskripsi, MK. So the LG's nama is the name of the learning goal. So the user is filtering on lg.nama = ""Aljabar Linear"". If the actual data has a different nama, like ""Aljabar linear"" with a lowercase 'l' in ""linear"", that would cause no matches.",False,3,False,0.03357001693610493,0.0514,0.5273603422522247,0.04861111111111111,False,0.0,2.8938017112611236,Fakta Implisit,Multi-hop,Easy,"empty_result,syntax_error"
40,Sebutkan mata kuliah-mata kuliah yang harus saya ambil sebelum dapat mengambil mata kuliah Persamaan Differensial pada tiap semester.,"MATCH (p:MK)-[r:PREREQUISITE*]->(t:MK {nama: 'Persamaan Differensial'}) RETURN p.nama, p.semester","MATCH (prereq:MK)-[:PREREQUISITE]->(pd:MK {nama: 'Persamaan Differensial'}) RETURN prereq.nama AS nama, prereq.semester AS semester",True,1,True,0.46414284388974053,0.6061,0.875898800652899,0.5714285714285714,False,0.6666666666666666,60.74332733659782,Fakta Implisit,Multi-hop,Easy,
41,"Apa saja capaian pembelajaran (LO), beserta deskripsinya, dari mata kuliah yang menjadi prasyarat untuk mata kuliah 'Proyek Senior Teknologi Informasi'?","MATCH (l:LO)-[:PURSUED_IN]->(m1:MK)-[:PREREQUISITE]->(m2:MK {nama: 'Proyek Senior Teknologi Informasi'}) RETURN l.nama, l.deskripsi","MATCH (m:MK {nama: ""Proyek Senior Teknologi Informasi""})<-[:PREREQUISITE]-(prereq:MK)-[:PURSUED_IN]-(lo:LO) RETURN DISTINCT lo.nama AS nama_capaian, lo.deskripsi AS deskripsi_capaian",True,1,True,0.34722999797676185,0.4255,0.8503230822020631,0.4166666666666667,True,1.0,100.0,Fakta Implisit,Multi-hop,Easy,
42,Berapakah jumlah total topik yang terhubung dengan Capaian Pembelajaran (LO) di 'Aljabar Linear'?,MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN count(t),MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN count(DISTINCT t) AS total_topics,True,1,True,0.7651248653630724,0.7895,0.9638342277877161,0.631578947368421,True,1.0,100.0,Fakta Implisit,Multi-hop,Medium,
43,Hitung jumlah Capaian Lulusan (SO) yang terkait (via LG) untuk setiap mata kuliah semester 1.,"MATCH (s:SO)-[:PART_OF]->(l:LG)-[:PURSUED_IN]->(m:MK) WHERE m.semester = 1 RETURN m.nama, count(s) AS jumlahSO","<think> Okay, let's tackle this problem. The user wants to count the number of Capaian Lulusan (SO) related via LG for each first-semester course (MK). First, I need to find all MK nodes where semester is 1. Then, for each of those MKs, find the LGs that are pursued in them. From those LGs, get the SOs that are part of them. Finally, count the distinct SOs per MK. Looking at the schema, the relationships are: - LG is pursued in MK via PURSUED_IN. - SO is part of LG via PART_OF. So the correct pattern is MK <-[:PURSUED_IN]- LG <-[:PART_OF]- SO. In Cypher, relationships are directional. The original schema shows that LG has a PURSUED_IN relationship to MK, so to get from MK to LG, it's (mk)-[:PURSUED_IN]->(lg). Similarly, SO has a PART_OF relationship to LG, so (so)-[:PART_OF]->(lg). Therefore, to traverse from MK to LG to SO, the query should be: MATCH (mk:MK {semester: 1})-[:PURSUED_IN]->(lg:LG)-[:PART_OF]->(so:SO) Then, group by mk.kode and count the distinct so.kode. Wait, but the user wants to count the number of SOs per MK. So the query would be: MATCH (mk:MK {semester: 1})-[:PURSUED_IN]->(lg:LG)-[:PART_OF]->(so:SO) RETURN mk.kode AS mk_kode, COUNT(DISTINCT so.kode) AS jumlah_so GROUP BY mk.kode But in the previous attempt, the user had the direction reversed. They used <-[:PURSUED_IN]- which is incorrect because the relationship is from LG to MK. So the correct direction is (mk)-[:PURSUED_IN]->(lg). Also, the error message mentioned an invalid input '<' at line 1, column 9. That's because the original query had something like (mk:MK {semester: 1})<-[:PURSUED_IN]-(lg:LG), which is incorrect. The correct direction is (mk)-[:PURSUED_IN]->(lg). So the corrected query should have the relationships in the correct direction. Let me structure it step by step: 1. Match MK with semester 1.",False,3,False,0.03977674240665454,0.0724,0.5352230440572218,0.0916030534351145,False,0.0,3.038115220286109,Fakta Implisit,Multi-hop,Medium,syntax_error
44,"Tampilkan Capaian Lulusan (SO) yang terhubung ke topik, urutkan berdasarkan jumlah topik terbanyak.","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO) RETURN s.kode AS kodeSO, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC","<think> Okay, let's tackle this problem. The user wants to display Capaian Lulusan (SO) connected to topics, sorted by the number of topics in descending order. The previous query had a syntax error, so I need to figure out what went wrong. First, looking at the schema: topics are connected to LO via PART_OF, and LO is connected to SO via PART_OF. So the path is topic -> LO -> SO. The correct MATCH should be (topic:topic)-[:PART_OF]->(lo:LO)-[:PART_OF]->(so:SO). The error message mentioned an invalid input '<' at line 1, column 9. That probably means the user used a left arrow incorrectly. In Cypher, relationships can be written in either direction, but the direction matters. If the relationship is from A to B, you can write (A)-[:REL]->(B) or (B)<-[:REL]-(A). So if the user tried to start from SO and go back, they might have written (so)<-[:PART_OF]-(lo), which is correct if the relationship is from lo to so. But maybe the user missed a keyword like RETURN or had a misplaced clause. Another possibility is that the user forgot to include the RETURN clause or had a syntax error in the ORDER BY. Let me reconstruct the query step by step. The correct approach is to match all SO nodes connected through LO and topic, count the topics per SO, and order by that count. So the query should be: MATCH (so:SO)<-[:PART_OF]-(lo:LO)<-[:PART_OF]-(topic:topic) RETURN so, COUNT(topic) AS topicCount ORDER BY topicCount DESC Wait, but the user might have written the relationships in the wrong order. Let me check the relationships again. The PART_OF from topic to LO is (topic)-[:PART_OF]->(lo), and then from LO to SO is (lo)-[:PART_OF]->(so). So the correct path is topic -> LO -> SO. So the MATCH should be (topic:topic)-[:PART_OF]->(lo:LO)-[:PART_OF]->(so:SO). But the user is trying to start from SO and go back. So maybe the correct way is to match (so:SO) and then traverse through the relationships. Wait, the error was about an invalid '<' character. Maybe the user used a left arrow incorrectly.",False,3,False,0.04088471286033728,0.0705,0.5408588970874382,0.0763888888888889,False,0.0,3.056794485437191,Fakta Implisit,Multi-hop,Medium,syntax_error
45,Capaian Lulusan (SO) manakah yang terhubung dengan jumlah topik terbanyak (via LO)?,"MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO) RETURN s.kode AS kodeSO, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC LIMIT 1","MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PART_OF]->(so:SO) RETURN so, COUNT(DISTINCT t) AS topicCount ORDER BY topicCount DESC LIMIT 1",False,3,False,0.5676105494994665,0.72,0.8863393852524288,0.6086956521739131,False,0.3333333333333333,14.69836359292881,Fakta Implisit,Multi-hop,Medium,"syntax_error,properties_error"
46,Mata kuliah apa yang menjadi prasyarat untuk mata kuliah prasyarat 'Persamaan Differensial'?,MATCH (m1:MK)-[:PREREQUISITE*2]->(m3:MK {nama: 'Persamaan Differensial'}) RETURN DISTINCT m1.nama,MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK) WHERE mk.nama = 'Persamaan Differensial' RETURN prereq,True,1,True,0.3051953951333345,0.5926,0.8356614314258739,0.4666666666666667,False,0.0,47.14130715712937,Fakta Implisit,Multi-hop,Medium,
47,"Untuk setiap mata kuliah, ada berapa Learning Outcome (LO) unik yang didukung oleh topik-topik pembelajarannya?","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK) RETURN m.nama AS mataKuliah, COUNT(DISTINCT l) AS jumlahLOUnik","MATCH (mk:MK)<-[:PURSUED_IN]-(t:topic)-[:PART_OF]->(lo:LO) WITH mk, COLLECT(DISTINCT lo.nama) AS uniqueLOs RETURN mk.nama AS mataKuliah, SIZE(uniqueLOs) AS jumlahLOUnik",True,1,True,0.4118390766735915,0.5306,0.859986080724845,0.5909090909090909,False,0.952,65.99293040362423,Fakta Implisit,Multi-hop,Medium,
48,"Untuk mata kuliah 'Proyek Senior Teknologi Informasi', apa saja Student Outcome (SO) yang terkait, dan apa saja mata kuliah yang menjadi prasyarat untuk mengambilnya?","MATCH (p:MK)-[:PREREQUISITE]->(m:MK {nama: 'Proyek Senior Teknologi Informasi'}) MATCH (m)<-[:PURSUED_IN]-(l:LO)-[:PART_OF]->(s:SO) WITH m, s, COLLECT(DISTINCT p.nama) AS Prasyarat RETURN m.nama, s.kode, s.deskripsi, Prasyarat","MATCH (so:SO)-[:PURSUED_IN]->(mk:MK {nama: ""Proyek Senior Teknologi Informasi""}) WITH collect(so) AS sos MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: ""Proyek Senior Teknologi Informasi""}) RETURN sos, collect(prereq) AS prerequisites",True,3,False,0.2805535261420953,0.3333,0.8547147468625805,0.3870967741935484,False,0.0,45.940073734312904,Fakta Implisit,Multi-hop,Hard,syntax_error
49,"Tolong tampilkan semua topik dari mata kuliah prasyarat untuk 'Metode Numeris', dan beri label apakah SKS mata kuliah prasyarat itu 'Bobot Berat' (jika 3 SKS) atau 'Bobot Ringan' (jika bukan 3 SKS).","MATCH (t:topic)-[:PURSUED_IN]->(p:MK)-[:PREREQUISITE]->(m:MK {nama: 'Metode Numeris'}) WITH p.nama AS Prasyarat, t.deskripsi AS Topik, p.sks AS SKS RETURN Prasyarat, Topik, CASE WHEN SKS = 3 THEN 'Bobot Berat' ELSE 'Bobot Ringan' END AS Bobot","<think> Okay, let's see. The user wants to find all topics from the prerequisites of the course 'Metode Numeris' and label each prerequisite's SKS as 'Bobot Berat' if it's 3 SKS or 'Bobot Ringan' otherwise. First, I need to find the course 'Metode Numeris', which is an MK node with nama 'Metode Numeris'. Then, find its prerequisites via the PREREQUISITE relationship. Each prerequisite is another MK node. For each of those, get the topics that are pursued in them via the PURSUED_IN relationship. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Let me check the query again. Oh, maybe the direction of the relationship was incorrect. The PREREQUISITE relationship goes from the course to its prerequisites, so the correct pattern is (m)-[:PREREQUISITE]->(prereq). Then, topics are connected via (t:topic)-[:PURSUED_IN]->(prereq). Wait, the direction here might be important. If the topic is pursued in the prerequisite course, then the topic node has a PURSUED_IN relationship pointing to the MK node. So the correct pattern is (prereq:MK)<-[:PURSUED_IN]-(t:topic). So the correct MATCH clause should be MATCH (m:MK {nama: 'Metode Numeris'})-[:PREREQUISITE]->(prereq:MK)<-[:PURSUED_IN]-(t:topic). Then, for each prerequisite, check the SKS. Use a CASE statement: if prereq.sks = 3, then 'Bobot Berat', else 'Bobot Ringan'. Putting it all together: MATCH (m:MK {nama: 'Metode Numeris'})-[:PREREQUISITE]->(prereq:MK)<-[:PURSUED_IN]-(t:topic) RETURN t.nama AS nama_topik, CASE WHEN prereq.sks = 3 THEN 'Bobot Berat' ELSE 'Bobot Ringan' END AS bobot_sks Wait, but in the previous attempt, maybe there was a missing colon or incorrect relationship direction. Let me make sure all relationships are correctly directed. Also, ensure that the properties are correctly referenced. The SKS is a property of the",False,3,False,0.09710741487745725,0.1595,0.5440064321595933,0.17857142857142858,False,0.0,3.517532160797966,Fakta Implisit,Multi-hop,Hard,syntax_error
50,"Saya ingin tahu, untuk setiap Student Outcome (SO), ada berapa total topik materi yang mendukungnya, dan tolong dikelompokkan berdasarkan klasifikasi mata kuliahnya (misal 'Sains Dasar' atau 'Topik Teknik'","MATCH (t:topic)-[:PURSUED_IN]->(m:MK)<-[:PURSUED_IN]-(s:SO) WITH s, m.klasifikasi AS Klasifikasi, COUNT(t) AS JumlahTopik RETURN s.kode, COLLECT({klasifikasi: Klasifikasi, jumlah: JumlahTopik}) AS RincianTopik ORDER BY s.kode","<think> Okay, let's tackle this problem. The user wants to find, for each Student Outcome (SO), the total number of topics supporting it, grouped by the course classification (MK.klasifikasi). First, I need to start with the SO nodes. The relationships involved here are: topics are part of LOs, which are part of SOs. Then, topics are pursued in MKs. So the path should be SO <- PART_OF - LO <- PART_OF - topic - PURSUED_IN -> MK. Wait, the user mentioned that topics are part of LOs, which are part of SOs. So the correct relationship direction is SO has LOs, which have topics. So the query should match (so:SO)<-[:PART_OF]-(lo:LO)<-[:PART_OF]-(t:topic)-[:PURSUED_IN]->(mk:MK). Then, group by so.kode and mk.klasifikasi, and count the distinct topics. The previous error was a syntax error, probably due to incorrect grouping or missing keywords. In Cypher, when using aggregate functions like COUNT, you need to either use WITH to group the data first or use GROUP BY in the RETURN clause. The correct syntax would be to use MATCH to find all the relevant nodes, then RETURN the so.kode, mk.klasifikasi, and COUNT(DISTINCT t.nama) as total_topics, GROUP BY so.kode and mk.klasifikasi. Also, ensure that the relationships are correctly directed. I should check if the relationships are in the right direction. The PART_OF from LO to SO is correct as (so)<-[:PART_OF]-(lo). Similarly, topic is part of LO, so (lo)<-[:PART_OF]-(t). Then, topic is pursued in MK via PURSUED_IN. Another thing to verify is the labels: SO, LO, topic, MK. The properties are so.kode, mk.klasifikasi, and t.nama. Using COUNT(DISTINCT t.nama) to avoid duplicates. Putting it all together, the query should be: MATCH (so:SO)<-[:PART_OF]-(lo:LO)<-[:PART_OF]-(t:topic)-[:PURSUED_IN]->(mk:MK) RETURN so.kode, mk.klasifikasi, COUNT(DISTINCT t.nama) AS total_topics GROUP BY so.kode, mk.klasifikasi ORDER BY so.kode, mk.klasifikasi Wait, but",False,3,False,0.049738262927768874,0.1055,0.5494582990233364,0.10218978102189781,False,0.0,3.2747914951166823,Fakta Implisit,Multi-hop,Hard,syntax_error
51,"Tampilkan semua mata kuliah 'Wajib' yang punya prasyarat, lalu kumpulkan daftar Student Outcome (SO) dan juga daftar prasyarat untuk masing-masing mata kuliah tersebut.","MATCH (s:SO)-[:PURSUED_IN]->(m:MK {tipe: 'Wajib'}) MATCH (p:MK)-[:PREREQUISITE]->(m) WITH m, COLLECT(DISTINCT s.kode) AS DaftarSO, COLLECT(DISTINCT p.nama) AS DaftarPrasyarat RETURN m.nama, DaftarSO, DaftarPrasyarat","<think> Okay, let's tackle this problem. The user wants to find all 'Wajib' courses that have prerequisites and collect their Student Outcomes (SO) and prerequisites. The previous query had a syntax error, so I need to fix that. First, looking at the error message: ""Invalid input '<'"". Wait, the user's query might have had a less-than symbol where it shouldn't be. Let me check the original query again. Oh, maybe they used a less-than symbol instead of a colon or something else. Wait, the original query was: MATCH (mk:MK {klasifikasi: 'Wajib'})-[:PREREQUISITE]->(prereq:MK), (mk)-[:PURSUED_IN]-(so:SO) RETURN mk.nama AS mataKuliah, COLLECT(DISTINCT so.kode) AS studentOutcomes, COLLECT(DISTINCT prereq.kode) AS prasyarat But the error is about an invalid '<' input. Hmm, maybe there's a typo in the query. Wait, the user's corrected query might have had a mistake in the relationship direction or a missing colon. Wait, the error message points to line 1, column 9. Let me look at the corrected query again. Oh, maybe the user used a less-than symbol instead of a colon in the node label. For example, if they wrote (mk:MK {klasifikasi: 'Wajib'})-[:PREREQUISITE]->(prereq:MK), but maybe there's a typo in the relationship type. Wait, no. The error is about an invalid '<' character. Wait, maybe the user used a less-than symbol instead of a colon in the node label. Like, if they wrote (mk:MK {klasifikasi: 'Wajib'})-[:PREREQUISITE]->(prereq:MK), but maybe there's a typo in the relationship direction. Wait, no. The error is in the first line, column 9. Let me count the characters. The first part is MATCH (mk:MK {klasifikasi: 'Wajib'})-[:PREREQUISITE]->(prereq:MK), (mk)-[:PURSUED_IN]-(so:SO) RETURN ... So column 9 would be after MATCH (mk:MK {klasifikasi: 'Wajib'})-[:PREREQUISITE]->(prere",False,3,False,0.0578281626671478,0.0762,0.5516029469632099,0.09302325581395349,False,0.0,3.1390147348160498,Fakta Implisit,Multi-hop,Hard,"syntax_error,empty_result"
52,"Tampilkan Capaian Lulusan (SO) yang dikejar di 'Pemrograman Dasar', dan kumpulkan Tujuan Pembelajaran (LG) yang terkait.","MATCH (m:MK {nama: 'Pemrograman Dasar'})<-[:PURSUED_IN]-(so:SO) WITH m, so MATCH (so)-[:PART_OF]->(lg:LG) WITH m, so, COLLECT(lg.nama) AS daftarTujuan RETURN so.kode, daftarTujuan","MATCH (so:SO)-[:PURSUED_IN]->(mk:MK {nama: 'Pemrograman Dasar'}) MATCH (lg:LG)-[:PURSUED_IN]->(mk) RETURN so, collect(lg)",True,3,False,0.36545731504740964,0.4314,0.8439880753540446,0.631578947368421,False,0.3333333333333333,53.043607043436886,Fakta Implisit,Multi-hop,Hard,syntax_error
