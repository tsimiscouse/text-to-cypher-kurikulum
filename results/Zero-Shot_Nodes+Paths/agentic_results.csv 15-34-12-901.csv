question_id,question,ground_truth_query,generated_query,success,total_iterations,first_attempt_valid,bleu,rouge_l_f1,jaro_winkler,jaccard_cypher,pass_at_1,jaccard_output,llmetric_q,reasoning_level,sublevel,complexity,errors_encountered
1,Berapakah jumlah SKS untuk mata kuliah 'Aljabar Linear'?,MATCH (n:MK {nama: 'Aljabar Linear'}) RETURN n.sks,MATCH (m:MK {nama: 'Aljabar Linear'}) RETURN m.sks,True,1,True,0.6665865240112948,0.7778,0.9583705025275051,0.7777777777777778,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
2,Apakah nama lengkap dari mata kuliah dengan kode 'TKU211131'?,MATCH (n:MK {kode: 'TKU211131'}) RETURN n.nama,MATCH (m:MK) WHERE m.kode = 'TKU211131' RETURN m.nama,True,1,True,8.869511863657866e-155,0.6667,0.8857526080476901,0.6,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
3,Bagaimanakah deskripsi untuk Capaian Lulusan (SO) dengan kode 'KP.1'?,MATCH (n:SO {kode: 'KP.1'}) RETURN n.deskripsi,MATCH (s:SO {kode: 'KP.1'}) RETURN s.deskripsi AS deskripsi,True,1,True,0.6109455387717302,0.7,0.9319434951013899,0.7,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
4,Tampilkan seluruh mata kuliah yang ditawarkan pada semester 1.,MATCH (n:MK) WHERE n.semester = 1 RETURN n.nama,MATCH (m:MK) WHERE m.semester = 1 RETURN m,True,1,True,0.4197010774824036,0.6316,0.8806785243741766,0.7,False,0.14285714285714285,50.41853547901374,Fakta Eksplisit,Nodes,Easy,
5,Tampilkan nama dan kode untuk semua mata kuliah yang memiliki tipe 'Pilihan'.,"MATCH (n:MK) WHERE n.tipe = 'Pilihan' RETURN n.nama, n.kode","MATCH (m:MK) WHERE m.tipe = 'Pilihan' RETURN m.kode, m.nama",True,1,True,0.37903259135181483,0.5833,0.9377489177489178,0.8181818181818182,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
6,Apa sajakah klasifikasi unik yang ada untuk semua mata kuliah?,MATCH (n:MK) RETURN DISTINCT n.klasifikasi,MATCH (m:MK) RETURN COLLECT(DISTINCT m.klasifikasi) AS unique_classifications,True,1,True,0.21305413619585087,0.5556,0.862582467425367,0.5,False,0.0,47.09091233712684,Fakta Eksplisit,Nodes,Medium,
7,Berapakah jumlah total mata kuliah yang bertipe 'Wajib'?,MATCH (n:MK) WHERE n.tipe = 'Wajib' RETURN COUNT(n),MATCH (m:MK) WHERE m.tipe = 'Wajib' RETURN COUNT(m),True,1,True,0.5411927503805858,0.7,0.98,0.8,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
8,"Tampilkan semua mata kuliah, diurutkan berdasarkan semester dari awal hingga akhir.","MATCH (n:MK) RETURN n.nama, n.semester ORDER BY n.semester",MATCH (m:MK) RETURN m ORDER BY m.semester ASC,True,1,True,0.1860067949655926,0.5455,0.843949864867316,0.6,False,0.2777777777777778,52.50280487989214,Fakta Eksplisit,Nodes,Medium,
9,Sebutkan 5 mata kuliah yang diurutkan berdasarkan namanya.,MATCH (n:MK) RETURN n.nama ORDER BY n.nama LIMIT 5,MATCH (m:MK) RETURN m ORDER BY m.nama LIMIT 5,True,1,True,0.34245097009375325,0.6957,0.883571359578314,0.8,False,0.1388888888888889,50.67413457566935,Fakta Eksplisit,Nodes,Medium,
10,Berapakah rata-rata jumlah SKS pada tiap semester.,"MATCH (n:MK) RETURN n.semester, AVG(n.sks) ORDER BY n.semester","MATCH (m:MK) WITH m.semester AS semester, SUM(m.sks) AS total_sks_per_semester WITH COLLECT(total_sks_per_semester) AS total_sks_list RETURN AVG(total_sks_list) AS average_sks_per_semester",False,3,False,3.4148662076653353e-78,0.2449,0.5951887539777166,0.35294117647058826,False,0.0,4.200443769888583,Fakta Eksplisit,Nodes,Medium,syntax_error
11,Berapakah SKS minimum dan maksimum untuk mata kuliah dengan klasifikasi 'Sains Dasar'?,"MATCH (n:MK) WHERE n.klasifikasi = 'Sains Dasar' RETURN MIN(n.sks), MAX(n.sks)","MATCH (m:MK) WHERE m.klasifikasi = 'Sains Dasar' RETURN MIN(m.sks) AS min_sks, MAX(m.sks) AS max_sks",True,1,True,0.4299524507438839,0.6111,0.8661665590956209,0.6875,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
12,Apa saja 'jalur' peminatan mata kuliah yang terdapat pada kurikulum?,MATCH (n:MK) WHERE n.jalur IS NOT NULL RETURN DISTINCT n.jalur,MATCH (m:MK) RETURN DISTINCT m.jalur,True,1,True,2.984428797065476e-78,0.5,0.8447619047619048,0.45454545454545453,False,0.8,62.72380952380952,Fakta Eksplisit,Nodes,Medium,
13,Tolong daftarkan mata kuliah di tiap semester dan diurutkan per semester.,"MATCH (n:MK) WITH n.semester AS semester, COLLECT(n.nama) AS daftarMataKuliah RETURN semester, daftarMataKuliah ORDER BY semester",MATCH (m:MK) RETURN m ORDER BY m.semester,True,1,True,1.5916232349795744e-78,0.4286,0.5859179902107682,0.46153846153846156,False,0.004301075268817204,45.15861145643019,Fakta Eksplisit,Nodes,Hard,
14,Kelompokkan semua nama mata kuliah berdasarkan tipenya.,"MATCH (n:MK) WITH n.tipe AS tipeMK, COLLECT(n.nama) AS daftarMatkul RETURN tipeMK, daftarMatkul","MATCH (m:MK) RETURN m.tipe AS tipe, collect(m.nama) AS nama_mata_kuliah",True,1,True,0.19873241117714635,0.4516,0.8828475089717243,0.5384615384615384,True,1.0,100.0,Fakta Eksplisit,Nodes,Hard,
15,"Untuk mata kuliah 'Aljabar Linear' dan 'Statistika', kumpulkan semua deskripsi topik dari kedua mata kuliah tersebut.","UNWIND ['Aljabar Linear', 'Statistika'] AS namaMK MATCH (t:topic {MK: namaMK}) RETURN namaMK, COLLECT(t.deskripsi) AS daftarTopik","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama IN ['Aljabar Linear','Statistika'] RETURN t.deskripsi",True,1,True,0.31777003136760673,0.4,0.7170920860453974,0.47368421052631576,False,0.0,45.58546043022699,Fakta Eksplisit,Nodes,Hard,
16,"Hitung jumlah total mata kuliah, dan berikan juga jumlah mata kuliah yang memiliki klasifikasi 'Sains Dasar'.","MATCH (n:MK) WITH n, CASE WHEN n.klasifikasi = 'Sains Dasar' THEN 1 ELSE 0 END AS isSainsDasar RETURN count(n) AS total, sum(isSainsDasar) AS totalSainsDasar","<think> Okay, let's see. The user wants to count the total number of courses (MK) and the number of courses classified as 'Sains Dasar'. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there was a typo or a missing keyword. Looking at the original query: MATCH (m:MK) RETURN count(m) AS total, sum(CASE WHEN m.klasifikasi = 'Sains Dasar' THEN 1 ELSE 0 END) AS sainsDasarCount. The error is at line 1, column 9. Wait, column 9 is the 'C' in ""CASE"". Oh, maybe the problem is that Cypher doesn't allow the CASE statement inside the SUM like that. Or perhaps the syntax is incorrect. Let me recall the correct Cypher syntax for conditional aggregation. In Cypher, you can use a CASE statement within an aggregate function, but maybe the syntax needs to be adjusted. Alternatively, maybe using a WITH clause to separate the counts would work better. Let me think. Another approach is to split the query into two parts: first count all MK nodes, then count those with klasifikasi 'Sains Dasar'. But how to combine them into a single query. Wait, maybe the issue is that the SUM with CASE is not allowed in the same RETURN clause. Or perhaps the CASE statement is not properly closed. Let me check the syntax again. The CASE statement should end with END. The original query has that. Hmm. Maybe the problem is that the SUM is not the right function here. Since we're just counting occurrences, using COUNT with a condition might be better. Oh right! In Cypher, you can use COUNT with a condition by filtering in a WHERE clause. So maybe using two separate MATCH clauses with WHERE conditions would be better. So, the corrected query could be: MATCH (m:MK) RETURN count(m) AS total, (MATCH (m:MK) WHERE m.klasifikasi = 'Sains Dasar' RETURN count(m)) AS sainsDasarCount. Wait, but that would require a subquery, which might not be allowed in a single RETURN. Alternatively, using a WITH clause to pass the total count and then compute the second count. Wait, the error message says ""Invalid input '<'"". The original query uses ""CASE WHEN..."" which starts with a '<' symbol? No, the error is pointing to",False,3,False,0.036695134459451606,0.0876,0.5358979260085825,0.1144578313253012,False,0.0,3.117489630042913,Fakta Eksplisit,Nodes,Hard,syntax_error
17,Sebutkan topik dan deskripsinya yang dibahas dalam mata kuliah 'Aljabar Linear',"MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN t.nama, t.deskripsi","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama = 'Aljabar Linear' RETURN t.nama, t.deskripsi",True,1,True,0.7199284907229773,0.9375,0.9390216473776574,0.8461538461538461,True,1.0,100.0,Fakta Implisit,One-hop,Easy,
18,Apakah Capaian Pembelajaran (LO) yang diharapkan dari mata kuliah 'Pemrograman Dasar'?,MATCH (l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Pemrograman Dasar'}) RETURN l.deskripsi,MATCH (lo:LO)-[:PURSUED_IN]->(mk:MK{nama:'Pemrograman Dasar'}) RETURN lo,True,1,True,0.6879186357518018,0.72,0.9697158846319415,0.6153846153846154,False,0.3333333333333333,55.11524608982637,Fakta Implisit,One-hop,Easy,
19,Apakah Tujuan Pembelajaran (LG) dari mata kuliah 'Aljabar Linear'?,MATCH (l:LG)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN l.deskripsi,"MATCH (lg:LG)-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN lg.nama, lg.deskripsi",True,1,True,0.6142746165268939,0.7143,0.922430919270363,0.6923076923076923,False,0.5,58.183654596351815,Fakta Implisit,One-hop,Easy,
20,Mata kuliah apa yang mencakup topik dengan deskripsi 'Determinan'?,MATCH (t:topic {deskripsi: 'Determinan'})-[:PURSUED_IN]->(m:MK) RETURN m.nama,MATCH (t:topic {deskripsi: 'Determinan'})-[:PURSUED_IN]->(m:MK) RETURN m,True,1,True,0.9200444146293233,0.9565,0.9855670103092784,0.9,False,0.16666666666666666,53.04366838487973,Fakta Implisit,One-hop,Easy,
21,Mata kuliah apa yang menjadi prasyarat untuk mengambil 'Kecerdasan Buatan'?,MATCH (p:MK)-[:PREREQUISITE]->(t:MK {nama: 'Kecerdasan Buatan'}) RETURN p.nama,MATCH (p:MK)-[:PREREQUISITE]->(m:MK {nama:'Kecerdasan Buatan'}) RETURN p,True,1,True,0.8211360240324279,0.8696,0.9659340659340659,0.8,False,0.15384615384615385,52.254593406593415,Fakta Implisit,One-hop,Easy,
22,Mata kuliah apa yang dapat diparalelkan dengan 'Fisika Mekanika Klasik'?,MATCH (m1:MK {nama: 'Fisika Mekanika Klasik'})-[:CAN_PARALLELIZED]->(m2:MK) RETURN m2.nama,MATCH (m:MK {nama: 'Fisika Mekanika Klasik'})-[:CAN_PARALLELIZED]->(other:MK) RETURN other.nama AS nama_mata_kuliah,True,3,False,0.671683390199399,0.6875,0.9343723842789263,0.5714285714285714,True,1.0,100.0,Fakta Implisit,One-hop,Easy,syntax_error
23,Berapakah jumlah topik yang ada pada mata kuliah 'Aljabar Linear'?,MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN count(t),"MATCH (t:topic)-[:PURSUED_IN]->(mk:MK {nama: ""Aljabar Linear""}) RETURN COUNT(t) AS jumlah_topik",True,2,False,0.6118223735011533,0.8276,0.9632009752699408,0.5,True,1.0,100.0,Fakta Implisit,One-hop,Medium,syntax_error
24,Sebutkan kode Capaian Lulusan (SO) unik yang dikejar (pursued) pada mata kuliah semester 1.,MATCH (s:SO)-[:PURSUED_IN]->(m:MK) WHERE m.semester = 1 RETURN DISTINCT s.kode,MATCH (so:SO)-[:PURSUED_IN]->(mk:MK) WHERE mk.semester = 1 RETURN DISTINCT so.kode,True,1,True,0.6148406922119201,0.7333,0.9549658058589364,0.7333333333333333,True,1.0,100.0,Fakta Implisit,One-hop,Medium,
25,"Tampilkan mata kuliah beserta jumlah topiknya, diurutkan secara menurun berdasarkan jumlah topik.","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) RETURN m.nama, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WITH m, COUNT(t) AS jumlah_topik RETURN m.nama AS nama_mata_kuliah, jumlah_topik ORDER BY jumlah_topik DESC",True,3,False,0.5816488689656844,0.6087,0.8903834075152375,0.7647058823529411,False,0.22388059701492538,51.9730289778747,Fakta Implisit,One-hop,Medium,syntax_error
26,Identifikasi 3 mata kuliah teratas yang memiliki jumlah topik terbanyak.,"MATCH (t:topic)-[:PURSUED_IN]->(m:MK) RETURN m.nama, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC LIMIT 3","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) RETURN m.kode AS kode,m.nama AS nama,COUNT(t) AS jumlah_topik ORDER BY jumlah_topik DESC LIMIT 3",True,1,True,0.5926737939437643,0.75,0.914785712172318,0.8333333333333334,False,0.6666666666666666,61.65726189419492,Fakta Implisit,One-hop,Medium,
27,Berapa mata kuliah prasyarat untuk mengambil mata kuliah Proyek Senior Teknologi Informasi?,MATCH (p:MK)-[:PREREQUISITE]->(t:MK {nama: 'Proyek Senior Teknologi Informasi'}) RETURN COUNT(p),"<think> Okay, let's tackle this problem. The user wants to find the number of prerequisite courses for ""Proyek Senior Teknologi Informasi"". First, I need to recall the schema. The PREREQUISITE relationship is between MK nodes. The direction is important here. If a course A has a prerequisite B, the relationship is A-[:PREREQUISITE]->B. Wait, no, actually, if B is a prerequisite for A, then A requires B. So the relationship should be from A to B. So when looking for prerequisites of A, we need to find all B where there's a PREREQUISITE relationship from A to B. Wait, that doesn't make sense. If B is a prerequisite for A, then to take A, you need to have taken B. So the correct direction would be A-[:PREREQUISITE]->B. So to find all prerequisites for A, we need to find all B where there's a relationship from A to B. Wait, that's the opposite. Let me think again. If course C requires D as a prerequisite, then D is the prerequisite. So the relationship should be from C to D. So when you match (mk:MK {nama: ""Proyek Senior Teknologi Informasi""})<-[:PREREQUISITE]-(prereq), that would mean that prereq is a prerequisite for mk. Because the arrow points from mk to prereq, meaning mk requires prereq. Wait, no, the direction is from the course to its prerequisite. So if mk has a PREREQUISITE relationship pointing to prereq, then prereq is a prerequisite for mk. So to find all prerequisites of mk, we need to find all nodes that have a PREREQUISITE relationship pointing to them from mk. So the correct pattern would be (mk)-[:PREREQUISITE]->(prereq). Wait, no, that would mean that mk is a prerequisite for prereq. That's the opposite. I'm getting confused here. Let me clarify. The PREREQUISITE relationship is from the course that requires the prerequisite to the prerequisite course. So if course X requires Y as a prerequisite, the relationship is X-[:PREREQUISITE]->Y. Therefore, to find all prerequisites for X, we need to find all Y where there's a PREREQUISITE relationship from X to Y. Wait, that can't be right.",False,3,False,0.025774977389558456,0.0476,0.5281651702409066,0.05714285714285714,False,0.0,2.878825851204533,Fakta Implisit,One-hop,Medium,syntax_error
28,Mata kuliah manakah yang paling banyak menjadi prasyarat bagi mata kuliah lainnya?,"MATCH (p:MK)-[:PREREQUISITE]->(t:MK) RETURN p.nama, count(t) AS jumlahMatkul ORDER BY jumlahMatkul DESC LIMIT 1",MATCH,False,3,False,8.487707814333063e-246,0.1,0.6792929292929294,0.06666666666666667,False,0.0,3.896464646464647,Fakta Implisit,One-hop,Medium,syntax_error
29,Sebutkan semua topik dari 'Metode Numeris' yang termasuk dalam 'LO1' atau 'LO2'.,"MATCH (t:topic)-[:PART_OF]->(l:LO {MK: 'Metode Numeris'}) WHERE l.nama IN ['LO1', 'LO2'] RETURN l.nama, t.deskripsi","MATCH (t:topic)-[:PURSUED_IN]->(mk:MK {nama: 'Metode Numeris'}) MATCH (t)-[:PART_OF]->(lo:LO) WHERE lo.nama IN ['LO1', 'LO2'] RETURN t",True,2,False,0.495860736694373,0.5778,0.8624516659810777,0.7368421052631579,False,0.25,52.201258329905386,Fakta Implisit,One-hop,Medium,syntax_error
30,Tolong kumpulkan semua deskripsi topik yang diajarkan di mata kuliah 'Aljabar Linear'.,"MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) WITH m, COLLECT(t.deskripsi) AS daftarTopik RETURN m.nama, daftarTopik","<think> Okay, let's see. The user wants to collect all descriptions of topics taught in the course 'Aljabar Linear'. The error in the previous query was a syntax issue. Let me check the schema again. The relevant nodes are 'topic' and 'MK'. The relationship is (topic)-[:PURSUED_IN]->(MK). So, I need to match topics connected to MK where MK's name is 'Aljabar Linear' and return their descriptions. In Cypher, the correct syntax would be MATCH (t:topic)-[:PURSUED_IN]->(mk:MK) WHERE mk.nama = 'Aljabar Linear' RETURN t.deskripsi. Wait, but the user mentioned ""kumpulkan"", which means collect. Maybe they want a list. So perhaps using COLLECT(t.deskripsi) to aggregate into a list. But the example in the instructions uses RETURN n, which returns nodes. However, the user specifically wants the descriptions, not the nodes. So returning the property is okay. But the error message might have been due to a missing keyword or incorrect syntax. Let me check the previous query again. The user's previous query had an error at line 1, column 9. The error message says invalid input '<'. Oh, maybe they used a different relationship direction. Wait, in the schema, the relationship is (topic)-[:PURSUED_IN]->(MK), so the direction is from topic to MK. So the correct pattern is (t:topic)-[:PURSUED_IN]->(mk:MK). If the previous query had the direction reversed, that would cause an error. Also, ensure that the WHERE clause correctly references mk.nama. Also, make sure that the string 'Aljabar Linear' is in quotes. Let me reconstruct the query step by step. Start with MATCH (t:topic)-[:PURSUED_IN]->(mk:MK). Then add WHERE mk.nama = 'Aljabar Linear'. Then RETURN t.deskripsi. That should work. Let me check for any syntax issues. All keywords are correctly spelled. The string is in quotes. The relationship direction is correct. So the corrected query should be: MATCH (t:topic)-[:PURSUED_IN]->(mk:MK) WHERE mk.nama = 'Aljabar Linear' RETURN t.deskripsi But the user might want to collect all into a list. However, the instruction says to return the node with properties. Wait, the user wants the descriptions,",False,3,False,0.0385665915104116,0.0737,0.5316927359244595,0.07894736842105263,False,0.0,3.026963679622298,Fakta Implisit,One-hop,Hard,syntax_error
31,Tolong verifikasi: Apakah topik 'Determinan' merupakan bagian dari 'LO1' pada 'Aljabar Linear'?,"MATCH (t:topic {deskripsi: 'Determinan'})-[:PART_OF]->(l:LO {nama: 'LO1', MK: 'Aljabar Linear'}) RETURN CASE WHEN l IS NOT NULL THEN 'Ya' ELSE 'Tidak' END AS Jawaban","<think> Okay, let's see. The user is asking to verify if the topic ""Determinan"" is part of ""LO1"" in ""Aljabar Linear"". The previous query didn't return any results, so I need to figure out why. First, the original query was: MATCH (t:topic {nama: ""Determinan""})-[:PART_OF]->(lo:LO {nama: ""LO1""})-[:PURSUED_IN]->(mk:MK {nama: ""Aljabar Linear""}) RETURN t, lo, mk. It failed because maybe the relationships are in the wrong direction or the properties are case-sensitive. Looking at the schema, the relationships are: (topic)-[:PART_OF]->(LO), (LO)-[:PART_OF]->(SO), (SO)-[:PART_OF]->(LG). Wait, but the user's query uses :PART_OF from topic to LO, which is correct. Then LO is connected to MK via :PURSUED_IN. Wait, the schema says (LO)-[:PURSUED_IN]->(MK). So the direction in the original query is correct. But maybe the issue is with the property values. The user wrote ""Aljabar Linear"" with uppercase letters. Maybe in the database, it's stored as lowercase or a different case. For example, maybe it's ""aljabar linear"" in the MK node. Since Neo4j is case-sensitive, that would cause a mismatch. Another possibility is that the LO's name isn't exactly ""LO1"". Maybe there's a typo or extra space. Also, maybe the topic's name isn't exactly ""Determinan"". Let me check the schema again. The topic has a 'nama' property. So all these properties are case-sensitive. To fix this, perhaps using OPTIONAL MATCH could help if any part of the chain is missing. Also, maybe using lowercase() function to compare case-insensitively. But the user's query uses exact matches. Alternatively, maybe the relationships are in the opposite direction. Wait, the schema says (topic)-[:PART_OF]->(LO), so the original query's direction is correct. Wait, the user's query is checking if the topic is part of LO1, which is pursued in MK. So the path is topic -> LO -> MK. That's correct based on the schema. So maybe the problem is the exact string values. Let me adjust the query to use lowercase() for the properties to make the match case-insensitive. For",False,3,False,0.03557237782058015,0.0874,0.5325484562336373,0.07228915662650602,False,0.0,3.099742281168187,Fakta Implisit,One-hop,Hard,"empty_result,syntax_error"
32,"Untuk mata kuliah 'Kalkulus Variabel Tunggal' dan 'Matematika Diskrit', apa saja topik materi yang diajarkan?","UNWIND ['Kalkulus Variabel Tunggal', 'Matematika Diskrit'] AS namaMK MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: namaMK}) RETURN namaMK, t.deskripsi","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama IN ['Kalkulus Variabel Tunggal','Matematika Diskrit'] RETURN t.nama AS nama_topik, t.deskripsi AS deskripsi_topik, m",True,1,True,0.5660150740130496,0.449,0.754490107358411,0.7142857142857143,False,0.125,48.517450536792055,Fakta Implisit,One-hop,Hard,
33,"Untuk setiap Tujuan Pembelajaran (LG) yang ada, sebutkan semua Capaian Lulusan (SO) yang menjadi bagiannya.","MATCH (s:SO)-[:PART_OF]->(l:LG) WITH l.nama AS namaLG, COLLECT(s.kode) AS daftarSO RETURN namaLG, daftarSO","<think> Okay, let's tackle this problem. The user wants to find all Capaian Lulusan (SO) that are part of each Tujuan Pembelajaran (LG). From the schema, there's a relationship (SO)-[:PART_OF]->(LG). So, to get each LG and its SOs, I need to match SO nodes that have a PART_OF relationship to LG nodes. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Looking at the original query, it was using (lg:LG)<-[:PART_OF]-(so:SO). Maybe the issue is with the direction of the relationship. Since the relationship is from SO to LG, using (so:SO)-[:PART_OF]->(lg:LG) would be correct. Alternatively, using the reverse direction with the left arrow might also work, but perhaps there was a typo or missing syntax. Wait, the error message says ""Invalid input '<'"". That suggests that the query started with something like MATCH (lg:LG)<-... which is valid, but maybe there was a missing part. Let me check the original query again. The user's previous attempt was: MATCH (lg:LG)<-[:PART_OF]-(so:SO) RETURN lg.nama AS nama_lg, so.nama AS nama_so. The error is about the '<' character. Hmm. Oh, maybe the problem is that the user used the left arrow direction but didn't have the correct syntax. Wait, in Cypher, (a)<-[:REL]->(b) is valid. So why the error? Maybe the user forgot to include the RETURN clause or had a typo elsewhere. Wait, the error message shows the line as starting with MATCH (lg:LG)<-... which is correct. But the error says ""Invalid input '<'"". That's confusing. Maybe the user's query had a different issue, like a missing RETURN or a typo in the keyword. Wait, looking at the error message again: the code is 'Neo.ClientError.Statement.SyntaxError', and the description says ""Invalid input '<': expected 'ALTER', 'ORDER BY', ..."". The line in question is line 1, column 9. Let me count the characters. The query starts with ""MATCH (lg:LG)<-[:PART_OF]-(so:SO) RETURN ..."". The first part is ""MATCH (lg:LG)"" which is correct. Then there's",False,3,False,0.02450737612920241,0.0526,0.5338128195352748,0.050955414012738856,False,0.0,2.932064097676374,Fakta Implisit,One-hop,Hard,syntax_error
34,"Tampilkan semua mata kuliah, beserta daftar mata kuliah prasyaratnya (jika ada).","MATCH (m:MK) OPTIONAL MATCH (p:MK)-[:PREREQUISITE]->(m) WITH m.nama AS nama, COLLECT(p.nama) AS prasyarat RETURN nama, prasyarat","MATCH (m:MK) OPTIONAL MATCH (m)-[:PREREQUISITE]->(prereq:MK) RETURN m, collect(prereq.nama) AS prerequisites",True,2,False,0.47347001922543064,0.5263,0.8656796217733307,0.6428571428571429,False,0.12133072407045009,49.38651259027566,Fakta Implisit,One-hop,Hard,syntax_error
35,Agregasikan semua deskripsi Capaian Pembelajaran (LO) yang berkontribusi pada kompetensi lulusan 'KP.1'.,"MATCH (l:LO)-[:PART_OF]->(s:SO {kode: 'KP.1'}) WITH s, COLLECT(l.deskripsi) AS daftarCapaian RETURN s.kode, daftarCapaian","<think> Okay, let's see. The user wants to aggregate all LO descriptions that contribute to the graduate competency 'KP.1'. First, I need to check the schema again. The labels are MK, LG, LO, topic, SO. Relationships include PART_OF and PURSUED_IN. The LG node has a 'kode' property. The user mentioned 'KP.1' as the LG's kode. So, the correct path should be LG (with kode 'KP.1') connected to SO via PART_OF, then SO connected to LO via PART_OF. Then collect the LO's deskripsi. In the previous query, there was a syntax error. The error message pointed to an invalid '<' at line 1, column 9. That probably means the direction of the relationship was incorrect. The original schema has (SO)-[:PART_OF]->(LG), so to get from LG to SO, the relationship should be (lg)<-[:PART_OF]-(so). But in Cypher, the direction is important. So the correct way is to match (lg:LG {kode: 'KP.1'})<-[:PART_OF]-(so:SO), then (so)<-[:PART_OF]-(lo:LO). Wait, the schema says (SO)-[:PART_OF]->(LG), so the SO is part of LG. Therefore, to find SOs that are part of LG, the query should be (so)-[:PART_OF]->(lg). But the user wants to start from LG, so the correct direction is (lg)<-[:PART_OF]-(so). Similarly, for LOs part of SOs, it's (lo)-[:PART_OF]->(so), so from SO to LO it's (so)<-[:PART_OF]-(lo). Putting it all together: MATCH (lg:LG {kode: 'KP.1'})<-[:PART_OF]-(so:SO)<-[:PART_OF]-(lo:LO) RETURN collect(lo.deskripsi) AS deskripsi_LO. Wait, but the user's previous query might have had a typo in the relationship direction. Let me check the error message again. The error was at line 1, column 9, which is the '<' in the relationship. Maybe the user used a left arrow incorrectly. So the correct syntax is to use the right direction. So the correct path is (lg:LG {kode: 'KP.1'})<-[:PART_OF]-(so:SO",False,3,False,0.035885863164716314,0.0773,0.5369431938884878,0.09375,False,0.0,3.0712159694424392,Fakta Implisit,One-hop,Hard,syntax_error
36,Hitung jumlah Capaian Pembelajaran (LO) di 'Metode Numeris' yang merupakan bagian dari SO 'KP.2'.,"MATCH (l:LO {MK: 'Metode Numeris'})-[:PART_OF]->(s:SO {kode: 'KP.2'}) WITH s, count(l) AS jumlahLO RETURN s.kode, jumlahLO",MATCH (mk:MK {nama:'Metode Numeris'})<-[:PURSUED_IN]-(lo:LO)-[:PART_OF]->(so:SO {kode:'KP.2'}) RETURN COUNT(lo) AS jumlah_LO,True,1,True,0.4400847633617821,0.5217,0.8661061017161529,0.5652173913043478,False,0.5,56.939030508580764,Fakta Implisit,One-hop,Hard,
37,Topik apa saja yang menjadi bagian dari Capaian Pembelajaran (LO) di 'Aljabar Linear'? berikan juga deskripsi topiknya,MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN t.nama,"MATCH (mk:MK {nama: ""Aljabar Linear""})<-[:PURSUED_IN]-(lo:LO)<-[:PART_OF]-(t:topic) RETURN t.nama AS nama_topik, t.deskripsi AS deskripsi_topik",True,3,False,0.37668194225588936,0.381,0.8426688189400054,0.42857142857142855,False,0.5,56.11834409470003,Fakta Implisit,Multi-hop,Easy,syntax_error
38,"Apa saja topik yang terkait dengan Capaian Lulusan (SO) 'KP.1' melalui LO. Berikan nama mata kuliah, nama topik dan deskripsi topiknya","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK) WHERE (l)-[:PART_OF]->(:SO {kode: 'KP.1'}) RETURN m.nama AS mataKuliah, t.nama AS namaTopic, t.deskripsi AS deskripsiTopik","<think> Okay, let's see. The user wants to find topics related to the SO 'KP.1' through LO. They need the course name, topic name, and description. First, I need to start with the SO node where kode is 'KP.1'. Then, find all LOs that are part of this SO. The relationship is LO-[:PART_OF]->SO, so I should match (so:SO {kode: 'KP.1'})<-[:PART_OF]-(lo:LO). Next, these LOs are part of topics. The relationship is topic-[:PART_OF]->LO, so (lo)<-[:PART_OF]-(topic:topic). Each topic is pursued in a MK via (topic)-[:PURSUED_IN]->(mk:MK). So I need to connect topic to MK. Now, I need to return mk.nama as nama_mata_kuliah, topic.nama, and topic.deskripsi. Putting it all together: MATCH (so:SO {kode: 'KP.1'})<-[:PART_OF]-(lo:LO)<-[:PART_OF]-(topic:topic)-[:PURSUED_IN]->(mk:MK) RETURN mk.nama, topic.nama, topic.deskripsi. Wait, but the user wants to ensure all parentheses are closed. Let me check the relationships again. The path from SO to LO to topic to MK. Each step should have the correct direction. Also, make sure that the labels are correct: LO, topic, MK, SO. I think that's right. Now, check for any syntax errors. The previous error was about invalid input '<', maybe because of the direction. Let me confirm the schema: (LO)-[:PART_OF]->(SO), so to get LOs under SO 'KP.1', it's (so)<-[:PART_OF]-(lo). That's correct. So the query should be: MATCH (so:SO {kode: 'KP.1'})<-[:PART_OF]-(lo:LO)<-[:PART_OF]-(topic:topic)-[:PURSUED_IN]->(mk:MK) RETURN mk.nama, topic.nama, topic.deskripsi. Wait, but the user mentioned that the previous query had an error at line 1, column 9. Let me check the syntax again. Oh, maybe the user used the wrong direction for the relationships. Let me make sure all relationships are correctly directed. The SO is part of LO, which is",False,3,False,0.06930647516544379,0.0984,0.5523528359277151,0.11538461538461539,False,0.0,3.253764179638576,Fakta Implisit,Multi-hop,Easy,syntax_error
39,Capaian Lulusan (SO) apa saja yang terkait dengan Tujuan Pembelajaran (LG) 'Aljabar Linear'?,MATCH (s:SO)-[:PART_OF]->(l:LG)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN s.kode,"<think> Okay, let's tackle this problem. The user wants to find all Capaian Lulusan (SO) related to the Tujuan Pembelajaran (LG) 'Aljabar Linear'. First, I need to recall the schema. From the given information, LG nodes are connected to MK via PURSUED_IN, and SO nodes are also connected to MK via PURSUED_IN. So the approach is to find the LG node with the name 'Aljabar Linear', get the MK it's connected to, and then find all SOs connected to that same MK. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Looking at the previous query, maybe there was a typo in the relationship direction. Let me check the relationships again. The correct relationships are: - (LG)-[:PURSUED_IN]->(MK) - (SO)-[:PURSUED_IN]->(MK) So, the correct way is to match the LG to MK, then match SO to the same MK. The user's initial attempt might have used a syntax like (lg)-[:PURSUED_IN]->(mk)<-[:PURSUED_IN]-(so), which is correct. But the error might be due to a missing quote or incorrect syntax in the WHERE clause. Wait, the error message points to line 1, column 9. Let me look at the previous query again. The user's query was: MATCH (lg:LG {nama: 'Aljabar Linear'})-[:PURSUED_IN]->(mk)<-[:PURSUED_IN]-(so:SO) RETURN so But the error is about an invalid '<' which might be due to the direction of the relationship. Wait, in Cypher, relationships can be directed or undirected. If the relationship is directed from SO to MK, then the correct direction would be (so)-[:PURSUED_IN]->(mk). So the previous query uses (mk)<-[:PURSUED_IN]-(so), which is correct if the relationship is from SO to MK. But maybe the user forgot to close a parenthesis or used incorrect syntax. Alternatively, maybe the user used a WHERE clause incorrectly. Let me think of the correct query. The correct approach is to first match the LG to MK, then match SO to MK. So the query should be: MATCH (lg:LG {nama: 'Aljabar Linear'})-[:",False,3,False,0.041752851164009806,0.0542,0.5275029201216621,0.06870229007633588,False,0.0,2.908514600608311,Fakta Implisit,Multi-hop,Easy,syntax_error
40,Sebutkan mata kuliah-mata kuliah yang harus saya ambil sebelum dapat mengambil mata kuliah Persamaan Differensial pada tiap semester.,"MATCH (p:MK)-[r:PREREQUISITE*]->(t:MK {nama: 'Persamaan Differensial'}) RETURN p.nama, p.semester","MATCH (prereq:MK)-[:PREREQUISITE]->(pd:MK) WHERE pd.nama = 'Persamaan Differensial' RETURN prereq.nama AS NamaMataKuliah, prereq.semester AS Semester",True,1,True,0.20092305281115508,0.5714,0.8500983866538626,0.4444444444444444,False,0.6666666666666666,60.440825266602644,Fakta Implisit,Multi-hop,Easy,
41,"Apa saja capaian pembelajaran (LO), beserta deskripsinya, dari mata kuliah yang menjadi prasyarat untuk mata kuliah 'Proyek Senior Teknologi Informasi'?","MATCH (l:LO)-[:PURSUED_IN]->(m1:MK)-[:PREREQUISITE]->(m2:MK {nama: 'Proyek Senior Teknologi Informasi'}) RETURN l.nama, l.deskripsi","MATCH (m:MK {nama: 'Proyek Senior Teknologi Informasi'})<-[:PREREQUISITE]-(prereq:MK)<-[:PURSUED_IN]-(lo:LO) RETURN lo.nama AS nama, lo.deskripsi AS desk",True,1,True,0.4151747069165081,0.4545,0.8797618807385733,0.6,True,1.0,100.0,Fakta Implisit,Multi-hop,Easy,
42,Berapakah jumlah total topik yang terhubung dengan Capaian Pembelajaran (LO) di 'Aljabar Linear'?,MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN count(t),MATCH (t:topic)-[:PART_OF]->(:LO)-[:PURSUED_IN]->(mk:MK {nama: 'Aljabar Linear'}) RETURN count(t) AS total_topics,True,1,True,0.8399870909551809,0.8333,0.9249031007751938,0.7058823529411765,True,1.0,100.0,Fakta Implisit,Multi-hop,Medium,
43,Hitung jumlah Capaian Lulusan (SO) yang terkait (via LG) untuk setiap mata kuliah semester 1.,"MATCH (s:SO)-[:PART_OF]->(l:LG)-[:PURSUED_IN]->(m:MK) WHERE m.semester = 1 RETURN m.nama, count(s) AS jumlahSO","<think> Okay, let's see. The user wants to count the number of Capaian Lulusan (SO) related via LG for each first-semester course (MK). First, I need to find all MK nodes where semester is 1. Then, these MK nodes are connected to LG via PURSUED_IN. Next, each LG is part of an SO through the PART_OF relationship. Wait, the schema says (SO)-[:PART_OF]->(LG), so the direction is from SO to LG. So to get from LG to SO, I need to traverse the inverse of PART_OF. In Cypher, relationships are directional. So if the original is (SO)-[:PART_OF]->(LG), then to get from LG to SO, I should match (lg)<-[:PART_OF]-(so). So the query should start by matching MK with semester 1, then connect to LG via PURSUED_IN, then from LG to SO via the inverse PART_OF. Then count the distinct SO per MK. Wait, the user's previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. That probably means there's a misplaced '<' in the relationship direction. Let me check the previous query again. Ah, maybe the user used (lg)<-[:PART_OF]-(so) correctly, but perhaps the issue was with the way the relationships were chained. Let me structure the MATCH clause properly. The correct pattern should be: MATCH (mk:MK {semester: 1})-[:PURSUED_IN]->(lg:LG)<-[:PART_OF]-(so:SO) Then return mk.kode and count distinct so, grouped by mk.kode. Wait, but the user's schema has (SO)-[:PART_OF]->(LG), so the correct way to get from LG to SO is (lg)<-[:PART_OF]-(so). So the relationship direction is correct here. Another possible issue: the user might have missed the 'RETURN' clause or had a syntax error in the GROUP BY. Let me make sure the query is correctly structured. Putting it all together: MATCH (mk:MK {semester: 1})-[:PURSUED_IN]->(lg:LG)<-[:PART_OF]-(so:SO) RETURN mk.kode, COUNT(DISTINCT so) AS jumlah_so GROUP BY mk.kode Wait, but the user's error was about an invalid '<",False,3,False,0.03779716814795614,0.0739,0.5273123512378527,0.08391608391608392,False,0.0,3.0060617561892635,Fakta Implisit,Multi-hop,Medium,syntax_error
44,"Tampilkan Capaian Lulusan (SO) yang terhubung ke topik, urutkan berdasarkan jumlah topik terbanyak.","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO) RETURN s.kode AS kodeSO, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC","<think> Okay, let's tackle this problem. The user wants to display Capaian Lulusan (SO) that are connected to topics, sorted by the number of topics in descending order. First, I need to understand the relationships from the schema. SO is connected to MK via PURSUED_IN. Topics are also connected to MK via PURSUED_IN. So, the SO and topics share the same MK nodes. The goal is to find SOs that have MKs which are also connected to topics. The initial query might have had a syntax error. The error message mentioned an invalid input '<', which probably means there's a typo in the relationship direction. In Cypher, relationships are defined with [-] and direction with -> or <-. So, the correct way to match both SO and topics connected to the same MK would be to have two separate relationships. For example, MATCH (so:SO)-[:PURSUED_IN]->(mk:MK)<-[:PURSUED_IN]-(t:topic). Then, group by so.kode (assuming kode is a unique identifier for SO) and count the number of topics. The RETURN clause should include the SO's kode, deskripsi, and the count. Also, order by the count in descending order. Wait, the error message pointed to line 1, column 9. Let me check the previous query. Oh, maybe the user missed a colon in the node labels or used incorrect relationship directions. For instance, using <- instead of <-[:REL_TYPE] might cause an error. So, the corrected query should properly define the relationships. Let me structure it step by step: 1. MATCH (so:SO)-[:PURSUED_IN]->(mk:MK)<-[:PURSUED_IN]-(t:topic) 2. Use WITH to aggregate the count of topics per SO. 3. GROUP BY so.kode and COUNT(t) AS jumlah_topik. 4. RETURN so.kode, so.deskripsi, jumlah_topik ORDER BY jumlah_topik DESC. Also, ensure that all keywords are correctly spelled and that the relationships are properly defined with the right direction and labels. Make sure to include the labels for all nodes involved. Another possible mistake could be missing the node labels in the relationships. For example, if the user wrote (mk) without :MK, that would be an error. But in the corrected query, we have (mk:MK), which is correct. So putting it all together, the final",False,3,False,0.030073710586409598,0.0652,0.5379302260781341,0.06395348837209303,False,0.0,3.015651130390671,Fakta Implisit,Multi-hop,Medium,syntax_error
45,Capaian Lulusan (SO) manakah yang terhubung dengan jumlah topik terbanyak (via LO)?,"MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO) RETURN s.kode AS kodeSO, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC LIMIT 1","<think> Okay, let's see. The user wants to find the SO (Capaian Lulusan) that is connected to the most topics through LO. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there's a missing colon or a typo in the relationship type. Looking at the schema, the relationships are: topic-PART_OF->LO-PART_OF->SO. So the path is topic -> LO -> SO. The user's query was trying to count topics per SO via LO. The original query was: MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PART_OF]->(so:SO) WITH so, COUNT(t) AS topicCount ORDER BY topicCount DESC LIMIT 1 RETURN so But the error was a syntax error. Wait, maybe the problem is that in the WITH clause, they didn't include the COUNT correctly. Or perhaps the ORDER BY is using a variable that's not in the WITH clause. Wait, in Cypher, when you use WITH, you need to include all variables you want to use in the next clauses. Let me check the correct syntax. Wait, the error message says ""Invalid input '<': expected ..."". The line starts with MATCH (t:topic)-... Maybe there's a missing colon or a typo in the relationship type. Wait, the relationships are PART_OF, so the syntax should be -[:PART_OF]->. But maybe the user used a different syntax. Wait, the error is at line 1, column 9. Let me count the characters. The first line starts with MATCH (t:topic)-[:PART_OF]->... So column 9 would be after the first part. Wait, maybe the user forgot to close a parenthesis or something. Wait, the original query might have had a typo in the relationship type. Wait, the user's query in the example had: MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PART_OF]->(so:SO) WITH so, COUNT(t) AS topicCount ORDER BY topicCount DESC LIMIT 1 RETURN so But in Cypher, after the MATCH, you need to have a RETURN or a WITH. The user used WITH, which is correct. But maybe the problem is that the COUNT is not in the WITH clause. Wait, no, the COUNT is part of the WITH. Wait, maybe the user forgot to put a",False,3,False,0.0524921939113124,0.0938,0.5398165506778397,0.10606060606060606,False,0.0,3.1680827533891986,Fakta Implisit,Multi-hop,Medium,"syntax_error,properties_error"
46,Mata kuliah apa yang menjadi prasyarat untuk mata kuliah prasyarat 'Persamaan Differensial'?,MATCH (m1:MK)-[:PREREQUISITE*2]->(m3:MK {nama: 'Persamaan Differensial'}) RETURN DISTINCT m1.nama,"<think> Okay, let's tackle this problem. The user is asking for the prerequisites of the prerequisite course ""Persamaan Differensial"". So first, I need to find the prerequisites of that course. In the schema, there's a PREREQUISITE relationship from MK to MK. So the course ""Persamaan Differensial"" is an MK node. I need to match that MK node first, then find what MK nodes are prerequisites for it. The initial query was incomplete, probably because of a syntax error. The error mentioned a string literal issue, maybe because the string wasn't properly quoted. The user's previous attempt had a line break in the string, which would cause a problem. So I need to make sure the string is correctly enclosed in double quotes without any line breaks. So the correct approach is to MATCH the MK node with nama ""Persamaan Differensial"", then find all MK nodes that have a PREREQUISITE relationship to it. Then return those MK nodes. Wait, no. Wait, the PREREQUISITE relationship is from MK to MK, meaning if A is a prerequisite for B, then A is connected to B via PREREQUISITE. So to find the prerequisites of ""Persamaan Differensial"", we need to find all MK nodes that have a PREREQUISITE relationship pointing to it. Wait, no. If the relationship is (A)-[:PREREQUISITE]->(B), that means A is a prerequisite for B. So B requires A. So to find the prerequisites of B, we look for incoming PREREQUISITE relationships to B. So the query should be MATCH (prereq:MK)-[:PREREQUISITE]->(m:MK {nama: ""Persamaan Differensial""}) RETURN prereq. But the user wants the prerequisites of the prerequisite course. Wait, the question is: ""Mata kuliah apa yang menjadi prasyarat untuk mata kuliah prasyarat 'Persamaan Differensial'?"" So it's asking for the prerequisites of the prerequisites of ""Persamaan Differensial"". Wait, no. Let me parse the question again. The question is asking for the prerequisites of the prerequisite course. So first, find the prerequisites of ""Persamaan Differensial"", then find the prerequisites of those prerequisites. Wait, the original question is in Indonesian. Let me translate it accurately.",False,3,False,0.02879911521854322,0.0497,0.48866607830346753,0.046153846153846156,False,0.0,2.6918303915173376,Fakta Implisit,Multi-hop,Medium,syntax_error
47,"Untuk setiap mata kuliah, ada berapa Learning Outcome (LO) unik yang didukung oleh topik-topik pembelajarannya?","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK) RETURN m.nama AS mataKuliah, COUNT(DISTINCT l) AS jumlahLOUnik","MATCH (mk:MK)-[:PURSUED_IN]-(topic)-[:PART_OF]->(lo:LO) RETURN mk.nama AS courseName, COUNT(DISTINCT lo) AS uniqueLOCount GROUP BY mk.nama",False,3,False,0.43832652125412735,0.4889,0.8658506316433858,0.5,False,0.0,6.773753158216929,Fakta Implisit,Multi-hop,Medium,syntax_error
48,"Untuk mata kuliah 'Proyek Senior Teknologi Informasi', apa saja Student Outcome (SO) yang terkait, dan apa saja mata kuliah yang menjadi prasyarat untuk mengambilnya?","MATCH (p:MK)-[:PREREQUISITE]->(m:MK {nama: 'Proyek Senior Teknologi Informasi'}) MATCH (m)<-[:PURSUED_IN]-(l:LO)-[:PART_OF]->(s:SO) WITH m, s, COLLECT(DISTINCT p.nama) AS Prasyarat RETURN m.nama, s.kode, s.deskripsi, Prasyarat","MATCH (m:MK {nama: ""Proyek Senior Teknologi Informasi""})<-[:PURSUED_IN]-(s:SO) WITH collect(s) AS sos MATCH (prereq:MK)-[:PREREQUISITE]->(m) RETURN sos, collect(prereq) AS prerequisites",True,2,False,0.36549714480819234,0.4848,0.8454345339383194,0.4827586206896552,False,0.0,46.6511726696916,Fakta Implisit,Multi-hop,Hard,syntax_error
49,"Tolong tampilkan semua topik dari mata kuliah prasyarat untuk 'Metode Numeris', dan beri label apakah SKS mata kuliah prasyarat itu 'Bobot Berat' (jika 3 SKS) atau 'Bobot Ringan' (jika bukan 3 SKS).","MATCH (t:topic)-[:PURSUED_IN]->(p:MK)-[:PREREQUISITE]->(m:MK {nama: 'Metode Numeris'}) WITH p.nama AS Prasyarat, t.deskripsi AS Topik, p.sks AS SKS RETURN Prasyarat, Topik, CASE WHEN SKS = 3 THEN 'Bobot Berat' ELSE 'Bobot Ringan' END AS Bobot","MATCH (m:MK {nama: 'Metode Numeris'})<-[:PREREQUISITE]-(prereq:MK)-[:PURSUED_IN]-(t:topic) RETURN t.nama AS Topik, CASE WHEN prereq.sks = 3 THEN 'Bobot Berat' ELSE 'Bobot Ringan' END AS Bobot_SKS",True,1,True,0.507317461177541,0.5867,0.8663079947342329,0.75,False,0.25,52.265039973671165,Fakta Implisit,Multi-hop,Hard,
50,"Saya ingin tahu, untuk setiap Student Outcome (SO), ada berapa total topik materi yang mendukungnya, dan tolong dikelompokkan berdasarkan klasifikasi mata kuliahnya (misal 'Sains Dasar' atau 'Topik Teknik'","MATCH (t:topic)-[:PURSUED_IN]->(m:MK)<-[:PURSUED_IN]-(s:SO) WITH s, m.klasifikasi AS Klasifikasi, COUNT(t) AS JumlahTopik RETURN s.kode, COLLECT({klasifikasi: Klasifikasi, jumlah: JumlahTopik}) AS RincianTopik ORDER BY s.kode","<think> Okay, let's tackle this problem. The user wants to find, for each Student Outcome (SO), the total number of topics supporting it, grouped by the course classification (MK's klasifikasi). First, I need to map the relationships. From the schema, SO is connected to MK via PURSUED_IN. Topics are also connected to MK via PURSUED_IN. So the path would be SO -> MK <- topic. But wait, topics are linked to MK directly. So for each SO, I need to find all MKs that are part of that SO, then get the topics linked to those MKs. Then count the topics per SO and group by MK's classification. Wait, the user wants the total topics per SO, grouped by the course's classification. So for each SO, we need to aggregate the topics across all MKs that are part of that SO, and categorize them based on the MK's klasifikasi. The Cypher query should start by matching (so:SO)-[:PURSUED_IN]->(mk:MK)<-[:PURSUED_IN]-(topic:topic). Then, group by so.kode and mk.klasifikasi, counting the topics. But the previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. That suggests there's an issue with the relationship direction. Let me check the schema again. The schema says (topic)-[:PURSUED_IN]->(MK), so the correct direction is topic to MK. So the relationship should be (topic)-[:PURSUED_IN]->(mk). Therefore, the correct pattern is (so)-[:PURSUED_IN]->(mk)<-[:PURSUED_IN]-(topic). Wait, no, if topic is connected to MK via PURSUED_IN, then it's (topic)-[:PURSUED_IN]->(mk). So the correct way to match is (topic)-[:PURSUED_IN]->(mk), and (so)-[:PURSUED_IN]->(mk). So the full pattern is (so)-[:PURSUED_IN]->(mk)<-[:PURSUED_IN]-(topic). So the MATCH clause should be MATCH (so:SO)-[:PURSUED_IN]->(mk:MK)<-[:PURSUED_IN]-(topic:topic). Then, group by so.kode and mk.klasifikasi, and count the topics. But the user also",False,3,False,0.04456457032233788,0.0815,0.5378019764481,0.06818181818181818,False,0.0,3.0965098822405004,Fakta Implisit,Multi-hop,Hard,syntax_error
51,"Tampilkan semua mata kuliah 'Wajib' yang punya prasyarat, lalu kumpulkan daftar Student Outcome (SO) dan juga daftar prasyarat untuk masing-masing mata kuliah tersebut.","MATCH (s:SO)-[:PURSUED_IN]->(m:MK {tipe: 'Wajib'}) MATCH (p:MK)-[:PREREQUISITE]->(m) WITH m, COLLECT(DISTINCT s.kode) AS DaftarSO, COLLECT(DISTINCT p.nama) AS DaftarPrasyarat RETURN m.nama, DaftarSO, DaftarPrasyarat","MATCH (mk:MK {klasifikasi: ""Wajib""})-[:PREREQUISITE]->(prereq:MK) WITH mk, COLLECT(DISTINCT prereq.kode) AS Prasyarat MATCH (so:SO)-[:PURSUED_IN]->(mk) WITH mk, Prasyarat, COLLECT(DISTINCT so.kode) AS SOs RETURN mk.nama AS MataKuliah, SOs, Prasyarat",False,3,False,0.3893977122284113,0.3944,0.863198922759526,0.4444444444444444,False,0.0,6.28799461379763,Fakta Implisit,Multi-hop,Hard,"empty_result,syntax_error"
52,"Tampilkan Capaian Lulusan (SO) yang dikejar di 'Pemrograman Dasar', dan kumpulkan Tujuan Pembelajaran (LG) yang terkait.","MATCH (m:MK {nama: 'Pemrograman Dasar'})<-[:PURSUED_IN]-(so:SO) WITH m, so MATCH (so)-[:PART_OF]->(lg:LG) WITH m, so, COLLECT(lg.nama) AS daftarTujuan RETURN so.kode, daftarTujuan","<think> Okay, let's tackle this problem. The user wants to find the Capaian Lulusan (SO) pursued in 'Pemrograman Dasar' and collect the related Tujuan Pembelajaran (LG). First, I need to match the MK node where the name is 'Pemrograman Dasar'. Then, find all SO nodes connected to that MK via the PURSUED_IN relationship. Next, for the LG part, I need to find all LG nodes that are also connected to the same MK via PURSUED_IN. Wait, the user mentioned ""related LG"". Are LG and SO connected through another relationship? According to the schema, SO is part of LG via PART_OF. But in the problem statement, the user wants LG that are related to the SOs. So maybe the LGs are those that are pursued in the same MK as the SOs. So the correct approach is to first get the MK node, then find all SOs and LGs that are pursued in that MK. Then return the SOs and collect the LGs. The previous query had a syntax error. The error message pointed to an invalid input '<' at line 1, column 9. That suggests there was a typo or missing character. Looking at the previous attempt, maybe the user tried to use a pattern with multiple relationships but didn't structure it correctly. The correct Cypher should use two separate matches: one for SO and one for LG, both connected to the same MK. Then collect the LGs. So the query would be: MATCH (mk:MK {nama: 'Pemrograman Dasar'})-[:PURSUED_IN]->(so:SO) MATCH (mk)-[:PURSUED_IN]->(lg:LG) RETURN so, collect(lg) Wait, but in the schema, the direction of the relationship might matter. The original relationships are (SO)-[:PURSUED_IN]->(MK), so the correct pattern is (so:SO)-[:PURSUED_IN]->(mk:MK). But in the previous attempt, the user might have had the direction reversed. So the correct MATCH should be: MATCH (so:SO)-[:PURSUED_IN]->(mk:MK {nama: 'Pemrograman Dasar'}) MATCH (lg:LG)-[:PURSUED_IN]->(mk) RETURN so, collect(lg) But the user's initial attempt might have had the relationships in",False,3,False,0.056102553790617384,0.1053,0.5230734749178848,0.1111111111111111,False,0.0,3.1418673745894243,Fakta Implisit,Multi-hop,Hard,syntax_error
