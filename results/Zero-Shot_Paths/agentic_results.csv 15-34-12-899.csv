question_id,question,ground_truth_query,generated_query,success,total_iterations,first_attempt_valid,bleu,rouge_l_f1,jaro_winkler,jaccard_cypher,pass_at_1,jaccard_output,llmetric_q,reasoning_level,sublevel,complexity,errors_encountered
1,Berapakah jumlah SKS untuk mata kuliah 'Aljabar Linear'?,MATCH (n:MK {nama: 'Aljabar Linear'}) RETURN n.sks,MATCH (m:MK {nama: 'Aljabar Linear'}) RETURN m.sks,True,1,True,0.6665865240112948,0.7778,0.9583705025275051,0.7777777777777778,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
2,Apakah nama lengkap dari mata kuliah dengan kode 'TKU211131'?,MATCH (n:MK {kode: 'TKU211131'}) RETURN n.nama,MATCH (m:MK {kode: 'TKU211131'}) RETURN m.nama,True,1,True,0.6389431042462724,0.75,0.9816809605488851,0.75,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
3,Bagaimanakah deskripsi untuk Capaian Lulusan (SO) dengan kode 'KP.1'?,MATCH (n:SO {kode: 'KP.1'}) RETURN n.deskripsi,MATCH (so:SO {kode: 'KP.1'}) RETURN so.deskripsi,True,1,True,0.6901670171940026,0.7778,0.9430594977428163,0.7777777777777778,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
4,Tampilkan seluruh mata kuliah yang ditawarkan pada semester 1.,MATCH (n:MK) WHERE n.semester = 1 RETURN n.nama,MATCH (m:MK) WHERE m.semester = 1 RETURN m,True,1,True,0.4197010774824036,0.6316,0.8806785243741766,0.7,False,0.14285714285714285,50.41853547901374,Fakta Eksplisit,Nodes,Easy,
5,Tampilkan nama dan kode untuk semua mata kuliah yang memiliki tipe 'Pilihan'.,"MATCH (n:MK) WHERE n.tipe = 'Pilihan' RETURN n.nama, n.kode","MATCH (m:MK) WHERE m.tipe = 'Pilihan' RETURN m.nama, m.kode",True,1,True,0.4062749424452353,0.6667,0.9256277056277057,0.8181818181818182,True,1.0,100.0,Fakta Eksplisit,Nodes,Easy,
6,Apa sajakah klasifikasi unik yang ada untuk semua mata kuliah?,MATCH (n:MK) RETURN DISTINCT n.klasifikasi,MATCH (m:MK) RETURN DISTINCT m.klasifikasi,True,1,True,0.4497332084013506,0.7143,0.9833333333333334,0.7142857142857143,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
7,Berapakah jumlah total mata kuliah yang bertipe 'Wajib'?,MATCH (n:MK) WHERE n.tipe = 'Wajib' RETURN COUNT(n),MATCH (m:MK) WHERE m.tipe = 'Wajib' RETURN COUNT(m) AS total,True,1,True,0.4790714250659131,0.6364,0.9552173913043478,0.6666666666666666,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
8,"Tampilkan semua mata kuliah, diurutkan berdasarkan semester dari awal hingga akhir.","MATCH (n:MK) RETURN n.nama, n.semester ORDER BY n.semester",MATCH (m:MK) RETURN m ORDER BY m.semester ASC,True,1,True,0.1860067949655926,0.5455,0.843949864867316,0.6,False,0.2777777777777778,52.50280487989214,Fakta Eksplisit,Nodes,Medium,
9,Sebutkan 5 mata kuliah yang diurutkan berdasarkan namanya.,MATCH (n:MK) RETURN n.nama ORDER BY n.nama LIMIT 5,"<think> Okay, let's tackle this problem. The user wants to list 5 courses sorted by their names. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there was a typo or a missing keyword. Looking at the schema, the courses are represented by the :MK nodes with a 'nama' property. The correct approach is to match all :MK nodes, order them by 'nama', and limit to 5. The initial query might have had something like ""ORDER BY <nama>"" which is incorrect. Oh right, in Cypher, you need to specify the property correctly. So the correct syntax should be ""ORDER BY n.nama"". Also, the user's previous attempt might have had a mistake in the RETURN clause. They should return the nodes or specific properties. Since the instruction says to return nodes with labels and properties, using RETURN n would be appropriate. But if the user wants just the names, it should be RETURN n.nama. However, the example given in the problem uses RETURN n, so maybe that's what's expected here. Wait, the error message shows an invalid '<' which might be from using a less-than symbol instead of a property. Maybe the original query had something like ORDER BY n.<nama> which is wrong. The correct is ORDER BY n.nama. Putting it all together, the correct query should be: MATCH (n:MK) RETURN n ORDER BY n.nama LIMIT 5. But wait, in Cypher, the order of clauses matters. The correct order is MATCH, then ORDER BY, then LIMIT, and finally RETURN. Wait no, the standard order is MATCH ... RETURN ... WITH ... etc. Wait, no, the correct syntax is MATCH ... RETURN ... with ORDER BY and LIMIT in the RETURN clause. Wait, no, ORDER BY and LIMIT are part of the RETURN clause. Let me check. In Cypher, the correct structure is: MATCH (n) RETURN n ORDER BY n.nama LIMIT 5. Yes, that's correct. So the previous query might have had the ORDER BY before RETURN, which is incorrect. The correct order is RETURN first, then ORDER BY and LIMIT. So the user's query probably had ORDER BY before RETURN, causing a syntax error. So the corrected query should be: MATCH (n:MK) RETURN n ORDER BY n.nama LIMIT 5. Let me make sure all the keywords are spelled correctly and the syntax is right. Yes",False,3,False,0.0264836439464726,0.0574,0.5322143226337275,0.059602649006622516,False,0.0,2.9480716131686378,Fakta Eksplisit,Nodes,Medium,syntax_error
10,Berapakah rata-rata jumlah SKS pada tiap semester.,"MATCH (n:MK) RETURN n.semester, AVG(n.sks) ORDER BY n.semester","MATCH (m:MK) RETURN m.semester AS semester, AVG(m.sks) AS average_sks",True,2,False,0.30480583461003735,0.4444,0.8515037593984962,0.5,False,0.125,48.97951879699248,Fakta Eksplisit,Nodes,Medium,syntax_error
11,Berapakah SKS minimum dan maksimum untuk mata kuliah dengan klasifikasi 'Sains Dasar'?,"MATCH (n:MK) WHERE n.klasifikasi = 'Sains Dasar' RETURN MIN(n.sks), MAX(n.sks)","MATCH (m:MK) WHERE m.klasifikasi = 'Sains Dasar' RETURN min(m.sks) AS min_sks, max(m.sks) AS max_sks",True,1,True,0.32795813790517186,0.6111,0.8661665590956209,0.6875,True,1.0,100.0,Fakta Eksplisit,Nodes,Medium,
12,Apa saja 'jalur' peminatan mata kuliah yang terdapat pada kurikulum?,MATCH (n:MK) WHERE n.jalur IS NOT NULL RETURN DISTINCT n.jalur,MATCH (m:MK) RETURN DISTINCT m.jalur,True,1,True,2.984428797065476e-78,0.5,0.8447619047619048,0.45454545454545453,False,0.8,62.72380952380952,Fakta Eksplisit,Nodes,Medium,
13,Tolong daftarkan mata kuliah di tiap semester dan diurutkan per semester.,"MATCH (n:MK) WITH n.semester AS semester, COLLECT(n.nama) AS daftarMataKuliah RETURN semester, daftarMataKuliah ORDER BY semester",MATCH (m:MK) RETURN m ORDER BY m.semester ASC,True,1,True,1.747716428142968e-78,0.4138,0.5954135388683857,0.42857142857142855,False,0.004301075268817204,45.13208919971827,Fakta Eksplisit,Nodes,Hard,
14,Kelompokkan semua nama mata kuliah berdasarkan tipenya.,"MATCH (n:MK) WITH n.tipe AS tipeMK, COLLECT(n.nama) AS daftarMatkul RETURN tipeMK, daftarMatkul","MATCH (m:MK) RETURN m.tipe AS tipe, collect(m.nama) AS nama_mata_kuliah",True,2,False,0.19873241117714635,0.4516,0.8828475089717243,0.5384615384615384,True,1.0,100.0,Fakta Eksplisit,Nodes,Hard,syntax_error
15,"Untuk mata kuliah 'Aljabar Linear' dan 'Statistika', kumpulkan semua deskripsi topik dari kedua mata kuliah tersebut.","UNWIND ['Aljabar Linear', 'Statistika'] AS namaMK MATCH (t:topic {MK: namaMK}) RETURN namaMK, COLLECT(t.deskripsi) AS daftarTopik","<think> Okay, let's tackle this problem. The user wants to collect all topic descriptions for the courses 'Aljabar Linear' and 'Statistika'. First, I need to check the schema. The relevant relationships here are PURSUED_IN between topic and MK. From the schema, it's (:topic)-[:PURSUED_IN]->(:MK). So the direction is from topic to MK. In the previous query, the user might have had the relationship direction reversed, which caused a syntax error. The correct direction is (t:topic)-[:PURSUED_IN]->(m:MK). Next, the WHERE clause should filter MK nodes where m.nama is either 'Aljabar Linear' or 'Statistika'. Using IN with a list of strings here makes sense. The RETURN statement needs to collect the descriptions. Since the user wants all descriptions, using COLLECT(t.deskripsi) would aggregate them into a list. But wait, the user might want each description as a separate row. However, the original instruction says ""kumpulkan"", which translates to ""collect"", so using COLLECT is appropriate here. Wait, but in the example provided in the feedback, they return individual rows. Hmm, maybe the user wants each topic's description as a separate entry. But the instruction says ""kumpulkan semua deskripsi topik"", which implies collecting them into a list. However, in Cypher, if you use COLLECT, it would group them into a list. But if you just return t.deskripsi, each row will be a separate description. The user might have intended to return all descriptions as a list. Let me check the example again. The user's example shows returning individual rows, but the instruction says ""kumpulkan"", which is to collect. So maybe the correct approach is to use COLLECT. However, the error in the previous query might have been due to incorrect syntax in the COLLECT usage. Let me structure the query properly. Putting it all together: MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama IN ['Aljabar Linear', 'Statistika'] RETURN COLLECT(t.deskripsi) AS descriptions. Wait, but if there are multiple topics per course, COLLECT would aggregate all into a single list. Alternatively, if each course has multiple topics, and the user wants all descriptions from both courses, then returning each t.deskripsi as a separate row would list all of them. But the",False,3,False,0.030137660410703423,0.0663,0.5213253639810597,0.07142857142857142,False,0.0,2.938126819905299,Fakta Eksplisit,Nodes,Hard,syntax_error
16,"Hitung jumlah total mata kuliah, dan berikan juga jumlah mata kuliah yang memiliki klasifikasi 'Sains Dasar'.","MATCH (n:MK) WITH n, CASE WHEN n.klasifikasi = 'Sains Dasar' THEN 1 ELSE 0 END AS isSainsDasar RETURN count(n) AS total, sum(isSainsDasar) AS totalSainsDasar","MATCH (m:MK) RETURN COUNT(m) AS total, SUM(CASE WHEN m.klasifikasi = 'Sains Dasar' THEN 1 ELSE 0 END) AS sainsDasar",True,1,True,0.3819779457830627,0.5306,0.8376409331945684,0.68,True,1.0,100.0,Fakta Eksplisit,Nodes,Hard,
17,Sebutkan topik dan deskripsinya yang dibahas dalam mata kuliah 'Aljabar Linear',"MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN t.nama, t.deskripsi","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE m.nama = ""Aljabar Linear"" RETURN t.nama, t.deskripsi",True,1,True,0.6989029944247108,0.9375,0.9369133420832296,0.6,True,1.0,100.0,Fakta Implisit,One-hop,Easy,
18,Apakah Capaian Pembelajaran (LO) yang diharapkan dari mata kuliah 'Pemrograman Dasar'?,MATCH (l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Pemrograman Dasar'}) RETURN l.deskripsi,MATCH (lo:LO)-[:PURSUED_IN]->(mk:MK) WHERE mk.nama = 'Pemrograman Dasar' RETURN lo,True,1,True,0.42333392640836565,0.6667,0.911091783335637,0.5333333333333333,False,0.3333333333333333,54.55562558334485,Fakta Implisit,One-hop,Easy,
19,Apakah Tujuan Pembelajaran (LG) dari mata kuliah 'Aljabar Linear'?,MATCH (l:LG)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN l.deskripsi,MATCH (lg:LG)-[:PURSUED_IN]->(mk:MK) WHERE mk.nama = 'Aljabar Linear' RETURN lg,True,1,True,0.42333392640836565,0.6667,0.9128164056320203,0.5333333333333333,False,0.3333333333333333,54.564248694826766,Fakta Implisit,One-hop,Easy,
20,Mata kuliah apa yang mencakup topik dengan deskripsi 'Determinan'?,MATCH (t:topic {deskripsi: 'Determinan'})-[:PURSUED_IN]->(m:MK) RETURN m.nama,MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WHERE t.deskripsi = 'Determinan' RETURN m,True,1,True,0.6130874895475292,0.72,0.8970117089462913,0.75,False,0.16666666666666666,51.418391878064796,Fakta Implisit,One-hop,Easy,
21,Mata kuliah apa yang menjadi prasyarat untuk mengambil 'Kecerdasan Buatan'?,MATCH (p:MK)-[:PREREQUISITE]->(t:MK {nama: 'Kecerdasan Buatan'}) RETURN p.nama,"MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: ""Kecerdasan Buatan""}) RETURN prereq",True,1,True,0.536197065805741,0.6957,0.8774907715895347,0.38461538461538464,False,0.15384615384615385,50.94287693487075,Fakta Implisit,One-hop,Easy,
22,Mata kuliah apa yang dapat diparalelkan dengan 'Fisika Mekanika Klasik'?,MATCH (m1:MK {nama: 'Fisika Mekanika Klasik'})-[:CAN_PARALLELIZED]->(m2:MK) RETURN m2.nama,"<think> Okay, let's tackle this problem. The user wants to find courses that can be parallelized with 'Fisika Mekanika Klasik'. The previous query had a syntax error. Let me look at the error message again. It says ""Invalid input '<' at line 1, column 9"". Hmm, maybe there's a typo or a missing quote. First, I need to match the MK node with the name 'Fisika Mekanika Klasik'. The correct relationship here is CAN_PARALLELIZED. The schema shows that CAN_PARALLELIZED connects MK nodes. So the query should start with MATCH (mk1:MK {nama: ""Fisika Mekanika Klasik""})-[:CAN_PARALLELIZED]-(mk2:MK). Wait, the error might be due to using single quotes instead of double quotes for the string. In Cypher, strings must be in double quotes. The previous query might have used single quotes, causing the syntax error. Let me check the example in the schema. All the properties use double quotes, like {kode: STRING}. So I need to make sure the nama value is in double quotes. Also, the direction of the relationship. CAN_PARALLELIZED is bidirectional, so using -[:CAN_PARALLELIZED]- is correct. The previous query might have used a directional arrow, like -> or <-, which could cause issues if the relationship is undirected. Another thing: the RETURN clause. The user needs to return the connected MK nodes. So after matching, the query should end with RETURN mk2. Putting it all together: MATCH (mk1:MK {nama: ""Fisika Mekanika Klasik""})-[:CAN_PARALLELIZED]-(mk2:MK) RETURN mk2. Wait, but maybe the user wants to exclude the same course. So adding a WHERE mk1.kode <> mk2.kode to avoid returning the same course. However, the original question doesn't specify excluding it, but logically, a course can't be parallelized with itself. Including that condition is safer. So the corrected query would be: MATCH (mk1:MK {nama: ""Fisika Mekanika Klasik""})-[:CAN_PARALLELIZED]-(mk2:MK) WHERE mk1.kode <> mk2.kode RETURN mk2. But the error in the previous query was a syntax error, so maybe the user missed the WHERE clause",False,3,False,0.030142564919796742,0.0625,0.5200921304393852,0.05194805194805195,False,0.0,2.912960652196926,Fakta Implisit,One-hop,Easy,syntax_error
23,Berapakah jumlah topik yang ada pada mata kuliah 'Aljabar Linear'?,MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN count(t),MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN COUNT(t),True,1,True,0.9025139799587886,1.0,1,1.0,True,1.0,100.0,Fakta Implisit,One-hop,Medium,
24,Sebutkan kode Capaian Lulusan (SO) unik yang dikejar (pursued) pada mata kuliah semester 1.,MATCH (s:SO)-[:PURSUED_IN]->(m:MK) WHERE m.semester = 1 RETURN DISTINCT s.kode,MATCH (so:SO)-[:PURSUED_IN]->(mk:MK) WHERE mk.semester = 1 RETURN DISTINCT so.kode,True,1,True,0.6148406922119201,0.7333,0.9549658058589364,0.7333333333333333,True,1.0,100.0,Fakta Implisit,One-hop,Medium,
25,"Tampilkan mata kuliah beserta jumlah topiknya, diurutkan secara menurun berdasarkan jumlah topik.","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) RETURN m.nama, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC","<think> Okay, let's see. The user wants to display courses along with the number of topics they have, sorted in descending order by the number of topics. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe the direction of the relationship was wrong. Let me check the schema again. The relationship is PURSUED_IN from topic to MK. So the correct direction should be (t:topic)-[:PURSUED_IN]->(m:MK). The previous query used (m:MK)<-[:PURSUED_IN]-(t:topic), which is technically correct because relationships can be matched in either direction. But maybe the issue is with the syntax. Wait, the error points to the '<' character. Oh, maybe the user used a less-than sign instead of a hyphen for the relationship direction? No, the user wrote <- correctly. Wait, maybe there's a missing space or a typo. Let me look at the original query again. The original query was: MATCH (m:MK)<-[:PURSUED_IN]-(t:topic) RETURN m.kode, m.nama, COUNT(t) AS jumlah_topik ORDER BY jumlah_topik DESC Wait, the error is at column 9. Let me count the characters. The first part is MATCH (m:MK). Then comes <-[:PURSUED_IN]-... The hyphen after (m:MK) is correct. Maybe the problem is that the user didn't use a WITH clause before ORDER BY? Because in Cypher, you can't have ORDER BY directly after RETURN. Oh right! The ORDER BY should come after RETURN. Wait, no, the correct syntax is RETURN ... ORDER BY. Wait, no, the correct order is MATCH ... RETURN ... ORDER BY. Wait, no, the correct order is MATCH ... RETURN ... ORDER BY. Wait, no, the correct syntax is MATCH ... RETURN ... ORDER BY. Wait, no, the correct order is MATCH ... RETURN ... ORDER BY. Wait, no, the correct order is MATCH ... RETURN ... ORDER BY. Wait, no, the correct syntax is MATCH ... RETURN ... ORDER BY. Wait, no, the correct order is MATCH ... RETURN ... ORDER BY. Wait, no, the correct syntax is MATCH ... RETURN ... ORDER BY. Wait, no, the correct order is MATCH ... RETURN ... ORDER BY. Wait, no, the correct syntax is MATCH ... RETURN ... ORDER BY.",False,3,False,0.0409503899103824,0.0789,0.5330467419718444,0.104,False,0.0,3.059733709859222,Fakta Implisit,One-hop,Medium,syntax_error
26,Identifikasi 3 mata kuliah teratas yang memiliki jumlah topik terbanyak.,"MATCH (t:topic)-[:PURSUED_IN]->(m:MK) RETURN m.nama, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC LIMIT 3","MATCH (t:topic)-[:PURSUED_IN]->(m:MK) WITH m.kode AS kode, m.nama AS nama, COUNT(t) AS jumlah_topik ORDER BY jumlah_topik DESC LIMIT 3 RETURN kode, nama, jumlah_topik",True,1,True,0.46634710000940727,0.6415,0.8800437952632609,0.7894736842105263,False,0.6666666666666666,60.941052309649635,Fakta Implisit,One-hop,Medium,
27,Berapa mata kuliah prasyarat untuk mengambil mata kuliah Proyek Senior Teknologi Informasi?,MATCH (p:MK)-[:PREREQUISITE]->(t:MK {nama: 'Proyek Senior Teknologi Informasi'}) RETURN COUNT(p),"MATCH (mk:MK {nama: ""Proyek Senior Teknologi Informasi""})<-[:PREREQUISITE]-(prereq:MK) RETURN COUNT(prereq) AS jumlah_prasyarat",True,1,True,0.33990330592058093,0.6452,0.8588757713757714,0.4444444444444444,True,1.0,100.0,Fakta Implisit,One-hop,Medium,
28,Mata kuliah manakah yang paling banyak menjadi prasyarat bagi mata kuliah lainnya?,"MATCH (p:MK)-[:PREREQUISITE]->(t:MK) RETURN p.nama, count(t) AS jumlahMatkul ORDER BY jumlahMatkul DESC LIMIT 1","<think> Okay, let's see. The user wants to find the course that is the most prerequisite for other courses. So, I need to count how many times each MK node is the source of a PREREQUISITE relationship. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there was a typo or incorrect use of parentheses. Let me check the correct Cypher syntax. The correct approach is to match all MK nodes that have outgoing PREREQUISITE relationships, count those relationships per node, and then order by the count in descending order. The user's initial attempt used SIZE() but that might not be the right approach. Instead, using COUNT(*) with a GROUP BY should work. So the query should be something like: MATCH (m:MK)-[:PREREQUISITE]->(other:MK) RETURN m.kode, COUNT(*) AS count ORDER BY count DESC LIMIT 1. Wait, but in the schema, the PREREQUISITE relationship is from a course to another course. So each m is a prerequisite for other courses. So counting how many times m is the source of PREREQUISITE gives the number of courses that require m as a prerequisite. That makes sense. I need to make sure that the syntax is correct. Let me check the parentheses and commas. Also, ensure that the keywords are spelled correctly. The error might have been due to a missing comma or incorrect use of parentheses. Let me structure the query properly. Another thing: the user mentioned that the previous query had an invalid input '<'. Maybe there was a misplaced '<' symbol. In Cypher, the direction of the relationship is indicated with '-', so for outgoing relationships, it's (m)-[:REL]->(other). So the correct pattern is (m:MK)-[:PREREQUISITE]->(other:MK). Putting it all together, the corrected query should match all MK nodes with outgoing PREREQUISITE relationships, group by m, count the occurrences, order by the count in descending order, and return the top one. The RETURN clause should include the MK's code and the count. Also, ensure that the keywords like MATCH, RETURN, ORDER BY, and LIMIT are correctly spelled and in the right order. So the final query would be: MATCH (m:MK)-[:PREREQUISITE]->(other:MK) RETURN m.kode AS kode, COUNT(*) AS count ORDER BY",False,3,False,0.02873271976362102,0.0597,0.528687915219046,0.06918238993710692,False,0.0,2.94193957609523,Fakta Implisit,One-hop,Medium,syntax_error
29,Sebutkan semua topik dari 'Metode Numeris' yang termasuk dalam 'LO1' atau 'LO2'.,"MATCH (t:topic)-[:PART_OF]->(l:LO {MK: 'Metode Numeris'}) WHERE l.nama IN ['LO1', 'LO2'] RETURN l.nama, t.deskripsi","MATCH (mk:MK {nama: 'Metode Numeris'})<-[:PURSUED_IN]-(t:topic)-[:PART_OF]->(lo:LO) WHERE lo.nama IN ['LO1', 'LO2'] RETURN t",True,1,True,0.5263321830271731,0.6047,0.8632982207665753,0.7368421052631579,False,0.25,52.33999110383288,Fakta Implisit,One-hop,Medium,
30,Tolong kumpulkan semua deskripsi topik yang diajarkan di mata kuliah 'Aljabar Linear'.,"MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) WITH m, COLLECT(t.deskripsi) AS daftarTopik RETURN m.nama, daftarTopik",MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN COLLECT(t.deskripsi),True,1,True,0.6572992345996989,0.7429,0.9129314159292036,0.8,False,0.5,58.27915707964602,Fakta Implisit,One-hop,Hard,
31,Tolong verifikasi: Apakah topik 'Determinan' merupakan bagian dari 'LO1' pada 'Aljabar Linear'?,"MATCH (t:topic {deskripsi: 'Determinan'})-[:PART_OF]->(l:LO {nama: 'LO1', MK: 'Aljabar Linear'}) RETURN CASE WHEN l IS NOT NULL THEN 'Ya' ELSE 'Tidak' END AS Jawaban","MATCH (t:topic {nama: ""Determinan""})-[:PART_OF]->(lo:LO {nama: ""LO1""})-[:PURSUED_IN]->(mk:MK {nama: ""Aljabar Linear""}) RETURN t, lo",False,3,False,0.3669213368347928,0.5306,0.8339041283793649,0.24242424242424243,False,0.0,6.8225206418968245,Fakta Implisit,One-hop,Hard,"syntax_error,empty_result"
32,"Untuk mata kuliah 'Kalkulus Variabel Tunggal' dan 'Matematika Diskrit', apa saja topik materi yang diajarkan?","UNWIND ['Kalkulus Variabel Tunggal', 'Matematika Diskrit'] AS namaMK MATCH (t:topic)-[:PURSUED_IN]->(m:MK {nama: namaMK}) RETURN namaMK, t.deskripsi","MATCH (t:topic)-[:PURSUED_IN]->(mk:MK) WHERE mk.nama IN [""Kalkulus Variabel Tunggal"",""Matematika Diskrit""] RETURN t.nama,t.deskripsi",True,2,False,0.4169553718210688,0.4762,0.7688990264265264,0.375,False,0.3333333333333333,52.89216179879929,Fakta Implisit,One-hop,Hard,syntax_error
33,"Untuk setiap Tujuan Pembelajaran (LG) yang ada, sebutkan semua Capaian Lulusan (SO) yang menjadi bagiannya.","MATCH (s:SO)-[:PART_OF]->(l:LG) WITH l.nama AS namaLG, COLLECT(s.kode) AS daftarSO RETURN namaLG, daftarSO","<think> Okay, let's tackle this problem. The user wants to find all Learning Outcomes (SO) that are part of each Learning Goals (LG). From the schema, there's a relationship from SO to LG called PART_OF. So the correct way is to match SO nodes that are connected to LG nodes via that relationship. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Looking at the previous query, maybe there was a typo or a missing keyword. The user's example query was something like MATCH (n:Label) RETURN n. So I need to structure the query correctly. The correct approach is to start with the LG nodes and find their connected SOs. Wait, no, the relationship is from SO to LG. So the direction is SO-[:PART_OF]->LG. So to get all SOs for each LG, we should match (so:SO)-[:PART_OF]->(lg:LG). Then return lg and collect the SOs. But the user wants to list all SOs for each LG. So in the return, we need to group by lg and collect the SOs. But the user's instruction says to return nodes with labels and properties. However, the example given is to return nodes, but maybe the user wants to return the LG and the list of SOs. But how to structure that in Cypher. The user's original question is in Indonesian: ""Untuk setiap Tujuan Pembelajaran (LG) yang ada, sebutkan semua Capaian Lulusan (SO) yang menjadi bagiannya."" So for each LG, list all SOs that are part of it. The correct query would be to match all SOs that are part of an LG, then group by LG and collect the SOs. In Cypher, the way to do that is to match the relationship and return the LG and collect the SOs. So the query should be: MATCH (so:SO)-[:PART_OF]->(lg:LG) RETURN lg, collect(so). But the user might want to return specific properties. However, the example in the instructions says to return nodes with labels and properties. So maybe just return the LG and the SOs as nodes. But the user's example uses RETURN n, which returns the entire node. So perhaps the correct query is to return lg and collect(so). But the error in the previous attempt might have been due to a missing",False,3,False,0.023439238279321387,0.0476,0.5376099399692866,0.05442176870748299,False,0.0,2.926049699846433,Fakta Implisit,One-hop,Hard,syntax_error
34,"Tampilkan semua mata kuliah, beserta daftar mata kuliah prasyaratnya (jika ada).","MATCH (m:MK) OPTIONAL MATCH (p:MK)-[:PREREQUISITE]->(m) WITH m.nama AS nama, COLLECT(p.nama) AS prasyarat RETURN nama, prasyarat","<think> Okay, let's see. The user wants to display all courses along with their prerequisite courses. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Hmm, maybe there's a typo or a missing keyword. Looking at the original query: MATCH (m:MK) OPTIONAL MATCH (m)-[:PREREQUISITE]->(prereq:MK) RETURN m.kode AS kode, m.nama AS nama, collect(prereq.nama) AS prasyarat. Wait, the error is about an invalid '<' character. Let me check the syntax again. Oh, maybe the arrow direction is wrong. In Neo4j, relationships are defined with --> or ->. Wait, the schema says the PREREQUISITE relationship is from the course to its prerequisite. So the direction should be (m)-[:PREREQUISITE]->(prereq). But the user's query uses that direction. So why the error? Wait, maybe the problem is that in the RETURN clause, collect(prereq.nama) would collect nulls for courses without prerequisites. But that's okay because collect() would just return an empty list. Hmm, but the error is a syntax error. Let me check the syntax again. The error is at line 1, column 9. Let me count the characters. The query starts with ""MATCH (m:MK) OPTIONAL MATCH (m)-[:PREREQUISITE]->(prereq:MK) RETURN m.kode AS kode, m.nama AS nama, collect(prereq.nama) AS prasyarat"". Oh, maybe the problem is that the user is using ""collect(prereq.nama)"" but in the OPTIONAL MATCH, if there's no prerequisite, prereq would be null. So collect(prereq.nama) would collect nulls, but maybe that's not the issue here. Wait, the error is a syntax error, not a runtime error. So maybe there's a missing comma or a typo in the query. Wait, looking at the error message: the invalid input '<' is at line 1, column 9. Let me check the query again. The first part is ""MATCH (m:MK) OPTIONAL MATCH (m)-[:PREREQUISITE]->(prereq:MK) RETURN ..."". The error is at column 9, which is after ""MATCH (m:MK) OPTIONAL"". Wait, maybe the user is missing a comma",False,3,False,0.05113469499631332,0.0984,0.5437057829695866,0.08943089430894309,False,0.0,3.210528914847933,Fakta Implisit,One-hop,Hard,syntax_error
35,Agregasikan semua deskripsi Capaian Pembelajaran (LO) yang berkontribusi pada kompetensi lulusan 'KP.1'.,"MATCH (l:LO)-[:PART_OF]->(s:SO {kode: 'KP.1'}) WITH s, COLLECT(l.deskripsi) AS daftarCapaian RETURN s.kode, daftarCapaian",MATCH (lo:LO)-[:PART_OF]->(:SO)-[:PART_OF]->(lg:LG {nama: 'KP.1'}) RETURN collect(lo.deskripsi) AS deskripsi_LO,True,1,True,0.404128168810639,0.4878,0.8510537001396279,0.5,False,0.0,46.69426850069814,Fakta Implisit,One-hop,Hard,
36,Hitung jumlah Capaian Pembelajaran (LO) di 'Metode Numeris' yang merupakan bagian dari SO 'KP.2'.,"MATCH (l:LO {MK: 'Metode Numeris'})-[:PART_OF]->(s:SO {kode: 'KP.2'}) WITH s, count(l) AS jumlahLO RETURN s.kode, jumlahLO",MATCH (lo:LO)-[:PART_OF]->(so:SO {kode: 'KP.2'})<-[:PART_OF]-(lo2:LO)-[:PURSUED_IN]->(mk:MK {nama: 'Metode Numeris'}) RETURN COUNT(lo2) AS jumlah_LO,True,1,True,0.3558590138236565,0.4,0.8294683937989964,0.5416666666666666,False,0.0,46.14734196899498,Fakta Implisit,One-hop,Hard,
37,Topik apa saja yang menjadi bagian dari Capaian Pembelajaran (LO) di 'Aljabar Linear'? berikan juga deskripsi topiknya,MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN t.nama,"MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PURSUED_IN]->(mk:MK) WHERE mk.nama = 'Aljabar Linear' RETURN t.nama AS nama_topik, t.deskripsi AS deskripsi_topik",True,1,True,0.5246438084756598,0.6818,0.8980394384689189,0.5238095238095238,False,0.5,57.899197192344594,Fakta Implisit,Multi-hop,Easy,
38,"Apa saja topik yang terkait dengan Capaian Lulusan (SO) 'KP.1' melalui LO. Berikan nama mata kuliah, nama topik dan deskripsi topiknya","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK) WHERE (l)-[:PART_OF]->(:SO {kode: 'KP.1'}) RETURN m.nama AS mataKuliah, t.nama AS namaTopic, t.deskripsi AS deskripsiTopik","MATCH (so:SO {kode: ""KP.1""})<-[:PART_OF]-(lo)<-[:PART_OF]-(topic)-[:PURSUED_IN]->(mk) RETURN mk.nama AS nama_mata_kuliah, topic.nama AS nama_topik, topic.deskripsi AS deskripsi_topik",True,2,False,0.32314867932070823,0.4375,0.8645668691532485,0.3448275862068966,False,0.9779411764705882,66.069157875178,Fakta Implisit,Multi-hop,Easy,syntax_error
39,Capaian Lulusan (SO) apa saja yang terkait dengan Tujuan Pembelajaran (LG) 'Aljabar Linear'?,MATCH (s:SO)-[:PART_OF]->(l:LG)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN s.kode,"<think> Okay, let's see. The user is asking for Capaian Lulusan (SO) related to the Learning Outcome (LG) 'Aljabar Linear'. The previous query was MATCH (so:SO)-[:PART_OF]->(lg:LG {nama: 'Aljabar Linear'}) RETURN so. But it returned empty results. Hmm. First, maybe the direction of the relationship is wrong. The schema says that SO is connected via PART_OF to LG. Wait, the schema shows that SO is part of LG, so the direction should be (SO)-[:PART_OF]->(LG). So the original query's direction is correct. But maybe the LG node's nama is not exactly 'Aljabar Linear'. Maybe there's a typo or case sensitivity. For example, maybe the actual nama is 'aljabar linear' with lowercase. The user mentioned case-sensitive. So perhaps the query should use a case-insensitive match. But how? In Cypher, you can use lowercase() or uppercase() functions. Alternatively, maybe the LG node is connected via a different relationship. Wait, the user's question is about LG 'Aljabar Linear', so the query should find SO nodes that are part of that LG. Let me check the schema again. The relationships are: (:SO)-[:PART_OF]->(:LG). So the correct pattern is (so:SO)-[:PART_OF]->(lg:LG {nama: 'Aljabar Linear'}). But maybe the nama is stored differently. Maybe the LG node's nama is not 'Aljabar Linear' exactly. Alternatively, maybe the query should use a different property. Wait, the LG node has a 'nama' property. So the query should be correct. But the error message was a syntax error. Let me check the query again. The original query was MATCH (so:SO)-[:PART_OF]->(lg:LG {nama: 'Aljabar Linear'}) RETURN so. The error message says invalid input '<' at line 1, column 9. Wait, maybe there's a typo in the query. Let me look again. Oh, maybe the user used a less-than symbol instead of a colon or something else. Wait, the error is about invalid input '<' which might be a character that's not supposed to be there. Let me check the query again. Oh, maybe the user used a less-than symbol in the query by mistake. Wait, the original query as written in the user's message is:",False,3,False,0.04164465942549832,0.0567,0.530853394969606,0.05673758865248227,False,0.0,2.93776697484803,Fakta Implisit,Multi-hop,Easy,"syntax_error,empty_result"
40,Sebutkan mata kuliah-mata kuliah yang harus saya ambil sebelum dapat mengambil mata kuliah Persamaan Differensial pada tiap semester.,"MATCH (p:MK)-[r:PREREQUISITE*]->(t:MK {nama: 'Persamaan Differensial'}) RETURN p.nama, p.semester","MATCH (m:MK {nama: 'Persamaan Differensial'})-[:PREREQUISITE]->(prereq:MK) RETURN prereq.nama AS nama_mk, prereq.semester AS semester",True,1,True,0.3956074248838666,0.4706,0.8689007986548971,0.5333333333333333,False,0.0,46.69750399327449,Fakta Implisit,Multi-hop,Easy,
41,"Apa saja capaian pembelajaran (LO), beserta deskripsinya, dari mata kuliah yang menjadi prasyarat untuk mata kuliah 'Proyek Senior Teknologi Informasi'?","MATCH (l:LO)-[:PURSUED_IN]->(m1:MK)-[:PREREQUISITE]->(m2:MK {nama: 'Proyek Senior Teknologi Informasi'}) RETURN l.nama, l.deskripsi","MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: ""Proyek Senior Teknologi Informasi""}), (lo:LO)-[:PURSUED_IN]->(prereq) RETURN DISTINCT lo.nama AS nama_lo, lo.deskripsi AS deskripsi_lo",True,2,False,0.46010132753103156,0.5,0.8538963508784481,0.4166666666666667,True,1.0,100.0,Fakta Implisit,Multi-hop,Easy,syntax_error
42,Berapakah jumlah total topik yang terhubung dengan Capaian Pembelajaran (LO) di 'Aljabar Linear'?,MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK {nama: 'Aljabar Linear'}) RETURN count(t),"MATCH (topic:topic)-[:PART_OF]->(:LO)-[:PURSUED_IN]->(mk:MK {nama: ""Aljabar Linear""}) RETURN count(DISTINCT topic)",True,3,False,0.6502122021282724,0.7647,0.9088244803401179,0.5,True,1.0,100.0,Fakta Implisit,Multi-hop,Medium,syntax_error
43,Hitung jumlah Capaian Lulusan (SO) yang terkait (via LG) untuk setiap mata kuliah semester 1.,"MATCH (s:SO)-[:PART_OF]->(l:LG)-[:PURSUED_IN]->(m:MK) WHERE m.semester = 1 RETURN m.nama, count(s) AS jumlahSO","<think> Okay, let's tackle this problem. The user wants to count the number of Capaian Lulusan (SO) related via LG for each course in semester 1. First, I need to look at the schema. The SO nodes are connected to LG via PART_OF, and LG is connected to MK via PURSUED_IN. So the path is SO -> PART_OF -> LG -> PURSUED_IN -> MK. But the user is interested in MKs in semester 1. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Let me check the original query again. Oh, maybe the user used the wrong direction for the relationships. In Neo4j, the direction matters. Let me make sure the relationships are correctly directed. The correct path should start from MK where semester is 1. Then, find LGs that are pursued in those MKs. Then, find SOs that are part of those LGs. So the relationships should be MK <-[:PURSUED_IN]- LG <-[:PART_OF]- SO. Wait, in the schema, the LG nodes have a PURSUED_IN relationship to MK. So the correct direction is LG-[:PURSUED_IN]->MK. But the user's query might have had the direction reversed. Let me check the schema again. Looking at the schema: (:LG {nama: STRING, deskripsi: STRING, MK: STRING})-[:PURSUED_IN]->(:MK {kode: STRING, nama: STRING, sks: INTEGER, durasi: STRING, tipe: STRING, klasifikasi: STRING, semester: INTEGER, jalur: STRING}) So LG is connected to MK via PURSUED_IN. Therefore, to get from MK to LG, we need to traverse the relationship in the reverse direction. So in the query, it should be (mk:MK {semester: 1})<-[:PURSUED_IN]-(lg:LG). Then, the SOs are connected to LG via PART_OF. The schema says (:SO {kode: STRING, deskripsi: STRING})-[:PART_OF]->(:LG {nama: STRING, deskripsi: STRING, MK: STRING}). So SO-[:PART_OF]->LG. Therefore, to get from LG to SO, we need to go in the reverse direction: (lg:LG)<-[:PART_OF]-(so:SO). Putting it all together,",False,3,False,0.03612328059743891,0.0672,0.5197440087145969,0.07692307692307693,False,0.0,2.9347200435729848,Fakta Implisit,Multi-hop,Medium,syntax_error
44,"Tampilkan Capaian Lulusan (SO) yang terhubung ke topik, urutkan berdasarkan jumlah topik terbanyak.","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO) RETURN s.kode AS kodeSO, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC","<think> Okay, let's tackle this problem. The user wants to display Capaian Lulusan (SO) that are connected to topics, sorted by the number of topics in descending order. First, I need to check the schema. The relevant relationships are: topic-PART_OF-LO, LO-PART_OF-SO. So each topic is part of an LO, which is part of an SO. So to get from SO to topics, the path is SO <- LO <- topic. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Looking at the previous query, maybe the direction of the relationships was written incorrectly. In Cypher, the direction matters. If the relationship is from topic to LO, then the correct pattern is (t:topic)-[:PART_OF]->(lo:LO). But in the previous query, the user might have written it as (lo)<-[:PART_OF]-(t), which is correct, but maybe there was a missing part in the MATCH clause. Wait, the user's previous query might have been something like MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PART_OF]->(so:SO) ... but maybe they didn't close the parentheses properly. Let me check the error message again. The error says ""Invalid input '<': expected ..."". The line 1, column 9 is where the problem is. Let me reconstruct the query. Ah, maybe the user wrote the relationships in the wrong direction. For example, if the relationships are PART_OF from topic to LO and from LO to SO, then the correct pattern is (t)-[:PART_OF]->(lo)-[:PART_OF]->(so). But if the user wrote (so)<-[:PART_OF]-(lo)<-[:PART_OF]-(t), that's also correct. However, in the previous query, perhaps there was a missing closing parenthesis or a misplaced bracket. Wait, the user's previous query might have been written as: MATCH (t:topic)-[:PART_OF]->(lo:LO)-[:PART_OF]->(so:SO) WITH so, COUNT(t) AS jumlah_topik ORDER BY jumlah_topik DESC RETURN so But maybe the user forgot to group by so, which is necessary when using COUNT. So the correct query should include GROUP BY so. However, in Cypher, when using WITH to aggregate, you need to include GROUP BY implicitly by including",False,3,False,0.048224868750573566,0.0863,0.5225041156464597,0.0821917808219178,False,0.0,3.044020578232299,Fakta Implisit,Multi-hop,Medium,syntax_error
45,Capaian Lulusan (SO) manakah yang terhubung dengan jumlah topik terbanyak (via LO)?,"MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO) RETURN s.kode AS kodeSO, count(t) AS jumlahTopik ORDER BY jumlahTopik DESC LIMIT 1","<think> Okay, let's see. The user is asking for the Student Outcome (SO) that is connected to the most topics via LO. The previous query had a syntax error. The error message mentioned an invalid input '<' which might be due to a typo or incorrect character. Let me check the original query again. The previous query was: MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO) WITH s, COUNT(DISTINCT t) AS total_topics ORDER BY total_topics DESC LIMIT 1 RETURN s, total_topics Wait, the error message says ""Invalid input '<'"". Hmm, maybe there was a typo in the query where a less-than symbol was accidentally included. But looking at the query, I don't see a '<' character. Maybe the user had a different version with a typo. Alternatively, maybe the problem is with the way the query is structured. Wait, the error message points to line 1, column 9. Let me count the characters. The query starts with MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PART_OF]->(s:SO). The first part is correct. The WITH clause is next. The error might be in the WITH clause. Wait, maybe the user used a comma incorrectly or missed a keyword. Let me check the syntax again. The correct syntax for WITH is to have a comma-separated list of variables and expressions. The user has ""WITH s, COUNT(DISTINCT t) AS total_topics"". That seems correct. Then ORDER BY total_topics DESC LIMIT 1. That should be okay. The RETURN s, total_topics is also correct. Wait, maybe the problem is that the user is using ""ORDER BY"" after ""WITH"" without a ""RETURN"" in between. Wait, no, the correct order is MATCH ... WITH ... ORDER BY ... LIMIT ... RETURN. So the structure is correct. Hmm, maybe the error is due to a missing space or a typo in the keywords. Let me check the keywords again. ""MATCH"", ""WITH"", ""ORDER BY"", ""LIMIT"", ""RETURN"" are all spelled correctly. The relationships are correctly named as PART_OF. The node labels are correct: topic, LO, SO. Wait, maybe the issue is that the user is using ""COUNT(DISTINCT t)"" but the variable t is a topic node. That should be okay. The error message mentions an invalid input '<', which isn't present in the query",False,3,False,0.06317030139270172,0.1024,0.5385337629293586,0.10191082802547771,False,0.0,3.204668814646794,Fakta Implisit,Multi-hop,Medium,"syntax_error,properties_error"
46,Mata kuliah apa yang menjadi prasyarat untuk mata kuliah prasyarat 'Persamaan Differensial'?,MATCH (m1:MK)-[:PREREQUISITE*2]->(m3:MK {nama: 'Persamaan Differensial'}) RETURN DISTINCT m1.nama,MATCH (m:MK {nama: 'Persamaan Differensial'})-[:PREREQUISITE]->(p:MK)-[:PREREQUISITE]->(q:MK) RETURN q.nama AS nama_mata_kuliah,False,3,False,0.40546144983876986,0.4242,0.8477508195453095,0.4375,False,0.0,6.359754097726547,Fakta Implisit,Multi-hop,Medium,"empty_result,syntax_error"
47,"Untuk setiap mata kuliah, ada berapa Learning Outcome (LO) unik yang didukung oleh topik-topik pembelajarannya?","MATCH (t:topic)-[:PART_OF]->(l:LO)-[:PURSUED_IN]->(m:MK) RETURN m.nama AS mataKuliah, COUNT(DISTINCT l) AS jumlahLOUnik","<think> Okay, let's tackle this problem. The user wants to find out, for each course (MK), how many unique Learning Outcomes (LO) are supported by its topics. First, I need to look at the schema provided. The relevant relationships here are PURSUED_IN and PART_OF. Topics are connected to MK via PURSUED_IN, and topics are part of LOs via PART_OF. So the path should be MK <- PURSUED_IN - topic - PART_OF -> LO. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. That suggests there might be a missing keyword or a misplaced symbol. Let me check the structure again. The correct way to match this would be to start with MATCH, then specify the nodes and relationships. The user might have missed a comma or a keyword in the MATCH clause. Also, the direction of relationships is important. Topics are pursued in MK, so the direction is (topic)-[:PURSUED_IN]->(MK), which in the query should be (mk)<-[:PURSUED_IN]-(t:topic). Then, topics are part of LOs via (t)-[:PART_OF]->(lo:LO). Another possible issue is the use of COUNT(DISTINCT lo). But the main error was a syntax one, so maybe the query was missing a RETURN clause or had a misplaced GROUP BY. Wait, in Cypher, the GROUP BY is not used in the same way as SQL. Instead, when using aggregate functions like COUNT, you need to include the non-aggregated properties in the RETURN clause. So the correct way is to RETURN mk.kode, COUNT(DISTINCT lo) AS unique_LO_count, and then order by the count if needed. Putting it all together, the correct query should match the MK nodes through their topics and LOs, then count the distinct LOs per MK. Let me make sure all the relationships are correctly directed and that the syntax is correct. Also, ensure that the properties are properly enclosed in curly braces if needed, but in this case, we're not filtering by properties, just matching the relationships. So the final query should look like: MATCH (mk:MK)<-[:PURSUED_IN]-(t:topic)-[:PART_OF]->(lo:LO) RETURN mk.kode AS kode_mk, COUNT(DISTINCT lo) AS unique_LO_count ORDER BY unique_LO_count DESC I need to check if there are",False,3,False,0.04776539292904897,0.0633,0.5353744817548535,0.06321839080459771,False,0.0,2.9933724087742677,Fakta Implisit,Multi-hop,Medium,syntax_error
48,"Untuk mata kuliah 'Proyek Senior Teknologi Informasi', apa saja Student Outcome (SO) yang terkait, dan apa saja mata kuliah yang menjadi prasyarat untuk mengambilnya?","MATCH (p:MK)-[:PREREQUISITE]->(m:MK {nama: 'Proyek Senior Teknologi Informasi'}) MATCH (m)<-[:PURSUED_IN]-(l:LO)-[:PART_OF]->(s:SO) WITH m, s, COLLECT(DISTINCT p.nama) AS Prasyarat RETURN m.nama, s.kode, s.deskripsi, Prasyarat","MATCH (mk:MK {nama: 'Proyek Senior Teknologi Informasi'}) OPTIONAL MATCH (so:SO)-[:PURSUED_IN]->(mk) OPTIONAL MATCH (prereq:MK)-[:PREREQUISITE]->(mk) RETURN DISTINCT so, prereq",True,2,False,0.30731935045982156,0.381,0.8401292604109506,0.42857142857142855,False,0.25,51.10564630205475,Fakta Implisit,Multi-hop,Hard,syntax_error
49,"Tolong tampilkan semua topik dari mata kuliah prasyarat untuk 'Metode Numeris', dan beri label apakah SKS mata kuliah prasyarat itu 'Bobot Berat' (jika 3 SKS) atau 'Bobot Ringan' (jika bukan 3 SKS).","MATCH (t:topic)-[:PURSUED_IN]->(p:MK)-[:PREREQUISITE]->(m:MK {nama: 'Metode Numeris'}) WITH p.nama AS Prasyarat, t.deskripsi AS Topik, p.sks AS SKS RETURN Prasyarat, Topik, CASE WHEN SKS = 3 THEN 'Bobot Berat' ELSE 'Bobot Ringan' END AS Bobot","<think> Okay, let's see. The user wants to find all topics from the prerequisites of the course 'Metode Numeris' and label each prerequisite's SKS as 'Bobot Berat' if it's 3 or 'Bobot Ringan' otherwise. First, I need to find the course 'Metode Numeris' which is a node with label MK and nama 'Metode Numeris'. Then, find its prerequisites via the PREREQUISITE relationship. The prerequisites are connected via (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: 'Metode Numeris'}). Next, for each prerequisite course (prereq), get the topics that are pursued in it. Topics are connected via (topic:topic)-[:PURSUED_IN]->(prereq). In the RETURN clause, I need to include the topic's name and description, and then use a CASE statement to check if the prerequisite's SKS is 3. If yes, label it 'Bobot Berat'; else, 'Bobot Ringan'. The previous query had a syntax error. The error message mentioned an invalid input '<' at line 1, column 9. Looking at the previous query, maybe there was a missing MATCH clause or incorrect structure. Let me reconstruct the correct query step by step. Start with MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: 'Metode Numeris'}) to get all prerequisites of 'Metode Numeris'. Then, MATCH (t:topic)-[:PURSUED_IN]->(prereq) to get the topics of each prerequisite. In the RETURN clause, include t.nama, t.deskripsi, and the CASE statement for prereq.sks. Wait, but the user wants all topics from the prerequisites. Each prerequisite can have multiple topics. So this query should work because for each prerequisite, it matches all its topics and returns them with the SKS label. Let me check the syntax again. The CASE statement should be correctly formatted. Also, ensure that all parentheses and commas are in place. The previous error might have been due to a missing MATCH clause or incorrect use of keywords. Putting it all together, the correct query should be: MATCH (prereq:MK)-[:PREREQUISITE]->(mk:MK {nama: 'Metode Numeris'}) MATCH (t:topic)-[:PURSUED_IN]->(prere",False,3,False,0.07517482722472112,0.0858,0.5531417532589914,0.14864864864864866,False,0.0,3.194708766294957,Fakta Implisit,Multi-hop,Hard,syntax_error
50,"Saya ingin tahu, untuk setiap Student Outcome (SO), ada berapa total topik materi yang mendukungnya, dan tolong dikelompokkan berdasarkan klasifikasi mata kuliahnya (misal 'Sains Dasar' atau 'Topik Teknik'","MATCH (t:topic)-[:PURSUED_IN]->(m:MK)<-[:PURSUED_IN]-(s:SO) WITH s, m.klasifikasi AS Klasifikasi, COUNT(t) AS JumlahTopik RETURN s.kode, COLLECT({klasifikasi: Klasifikasi, jumlah: JumlahTopik}) AS RincianTopik ORDER BY s.kode","<think> Okay, let's see. The user wants to find out for each Student Outcome (SO), the total number of topics supporting it, grouped by the course classification. The previous query had a syntax error because of the GROUP BY clause. Oh right, in Cypher, you can't just add GROUP BY after RETURN. You need to use WITH to aggregate. So the original query was: MATCH (so:SO)<-[:PART_OF]-(:LO)<-[:PART_OF]-(:topic)-[:PURSUED_IN]->(mk:MK) RETURN so.kode AS so_code, so.deskripsi AS so_description, mk.klasifikasi AS course_classification, COUNT(*) AS total_topics GROUP BY so.kode, so.deskripsi, mk.klasifikasi The mistake here is using GROUP BY after RETURN. In Cypher, after MATCH, you should use WITH to carry forward the variables you want to group by, then perform the aggregation. So the correct approach is to first MATCH the pattern, then use WITH to include the properties you need, and then use COUNT in the RETURN with GROUP BY. So the corrected query should be: MATCH (so:SO)<-[:PART_OF]-(:LO)<-[:PART_OF]-(:topic)-[:PURSUED_IN]->(mk:MK) WITH so.kode AS so_code, so.deskripsi AS so_description, mk.klasifikasi AS course_classification, COUNT(*) AS total_topics RETURN so_code, so_description, course_classification, total_topics Wait, but in the WITH clause, do I need to include all the variables I want to return? Yes. Then in the RETURN, just return those variables. Also, check if the COUNT is correctly placed. The COUNT should be in the WITH or RETURN. Let me think again. The COUNT is applied to the number of topics, so in the MATCH, each topic is matched, and we need to count them per group. So using WITH to group by the three properties and then count the number of topics. Then return those. So the corrected query should replace the GROUP BY with WITH and then RETURN. Also, make sure that the COUNT is in the WITH clause. Let me check the syntax again. The correct way is to use WITH to aggregate. So the corrected query would be: MATCH (so:SO)<-[:PART_OF]-(:LO)<-[:PART_OF]-(:topic)-[:PURSUED_IN]->(mk:MK) WITH so.kode AS so_code, so",False,3,False,0.04441179627918246,0.0784,0.5484003072912399,0.0916030534351145,False,0.0,3.1340015364562,Fakta Implisit,Multi-hop,Hard,syntax_error
51,"Tampilkan semua mata kuliah 'Wajib' yang punya prasyarat, lalu kumpulkan daftar Student Outcome (SO) dan juga daftar prasyarat untuk masing-masing mata kuliah tersebut.","MATCH (s:SO)-[:PURSUED_IN]->(m:MK {tipe: 'Wajib'}) MATCH (p:MK)-[:PREREQUISITE]->(m) WITH m, COLLECT(DISTINCT s.kode) AS DaftarSO, COLLECT(DISTINCT p.nama) AS DaftarPrasyarat RETURN m.nama, DaftarSO, DaftarPrasyarat","MATCH (mk:MK {klasifikasi: 'Wajib'})-[:PREREQUISITE]->(prereq:MK), (mk)-[:PURSUED_IN]-(so:SO) RETURN mk, collect(DISTINCT so) AS soList, collect(DISTINCT prereq) AS prereqList",False,3,False,0.2945269407410004,0.3448,0.837549080108995,0.4,False,0.0,5.911745400544975,Fakta Implisit,Multi-hop,Hard,"empty_result,syntax_error"
52,"Tampilkan Capaian Lulusan (SO) yang dikejar di 'Pemrograman Dasar', dan kumpulkan Tujuan Pembelajaran (LG) yang terkait.","MATCH (m:MK {nama: 'Pemrograman Dasar'})<-[:PURSUED_IN]-(so:SO) WITH m, so MATCH (so)-[:PART_OF]->(lg:LG) WITH m, so, COLLECT(lg.nama) AS daftarTujuan RETURN so.kode, daftarTujuan","<think> Okay, let's tackle this problem. The user wants to find the Capaian Lulusan (SO) pursued in 'Pemrograman Dasar' and collect the related Tujuan Pembelajaran (LG). First, I need to find the MK node where the name is 'Pemrograman Dasar'. So I'll start with MATCH (mk:MK) WHERE mk.nama = 'Pemrograman Dasar'. Next, I need to get the SO nodes that are pursued in this MK. The relationship is [:PURSUED_IN], so MATCH (so:SO)-[:PURSUED_IN]->(mk). Then, for each SO, I need to find the LG nodes that they are part of. The schema shows that SO is part of LG via [:PART_OF], so MATCH (so)-[:PART_OF]->(lg:LG). I should collect all the LGs related to each SO. So I'll use WITH so, collect(lg) as lgs. Wait, but the user wants to return each SO and collect the LGs. So maybe I need to group by SO and collect the LGs. Putting it all together: MATCH (mk:MK) WHERE mk.nama = 'Pemrograman Dasar' MATCH (so:SO)-[:PURSUED_IN]->(mk) MATCH (so)-[:PART_OF]->(lg:LG) RETURN so, collect(lg) Wait, but the error message mentioned a syntax error. Let me check the previous query. Oh, maybe the user had an incomplete query. The corrected version should have proper syntax. Wait, the user's previous attempt had a syntax error. Let me make sure all the keywords are correct. MATCH, WHERE, RETURN. Also, ensure that the relationships are correctly specified with the right direction. Another thing: the user might need to use WITH to pass variables between clauses. For example, after finding the MK, then find the SOs, then for each SO find the LGs. But in this case, maybe it's better to chain the matches. Wait, maybe the correct query is: MATCH (mk:MK {nama: 'Pemrograman Dasar'})<-[:PURSUED_IN]-(so:SO)-[:PART_OF]->(lg:LG) RETURN so, collect(lg) But wait, the user wants to collect all LGs related to each SO. So for each SO",False,3,False,0.0836687747299878,0.1253,0.5560154492852705,0.1171875,False,0.0,3.4065772464263526,Fakta Implisit,Multi-hop,Hard,syntax_error
